{"version":3,"file":"transform.js","sourceRoot":"","sources":["../../src/transform.ts"],"names":[],"mappings":"AAIA,OAAO,EAAiB,uBAAuB,EAAC,MAAM,WAAW,CAAC;AAClE,OAAO,EAAC,kBAAkB,EAAY,MAAM,aAAa,CAAC;AA4B1D,MAAM,UAAU,QAAQ,CAAC,CAAY;IACnC,OAAO,CAAC,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC;AACnC,CAAC;AA+LD,MAAM,UAAU,gBAAgB,CAAC,CAAqC;IACpE,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,SAAS,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC;AAClE,CAAC;AAsGD,MAAM,UAAU,QAAQ,CAAC,CAAY;IACnC,OAAO,CAAC,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC;AACnC,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,CAAY;IACnC,OAAO,CAAC,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC;AACnC,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,CAAY;IACnC,OAAO,CAAC,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC;AACnC,CAAC;AAED,MAAM,UAAU,SAAS,CAAC,CAAY;IACpC,OAAO,CAAC,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC;AACpC,CAAC;AACD,MAAM,UAAU,WAAW,CAAC,CAAY;IACtC,OAAO,CAAC,CAAC,WAAW,CAAC,KAAK,SAAS,CAAC;AACtC,CAAC;AAED,MAAM,UAAU,KAAK,CAAC,CAAY;IAChC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AACpB,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,CAAY;IACnC,OAAO,CAAC,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC;AACnC,CAAC;AAED,MAAM,UAAU,UAAU,CAAC,CAAY;IACrC,OAAO,CAAC,CAAC,UAAU,CAAC,KAAK,SAAS,CAAC;AACrC,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,CAAY;IACtC,OAAO,CAAC,CAAC,WAAW,CAAC,KAAK,SAAS,CAAC;AACtC,CAAC;AAED,MAAM,UAAU,OAAO,CAAC,CAAY;IAClC,OAAO,CAAC,CAAC,OAAO,CAAC,KAAK,SAAS,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,MAAM,CAAC,CAAY;IACjC,OAAO,CAAC,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC;AACjC,CAAC;AAgBD,MAAM,UAAU,kBAAkB,CAAC,SAAsB;IACvD,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;QACvB,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE;YACf,OAAO;gBACL,MAAM,EAAE,uBAAuB,CAAC,CAAC,CAAC,MAAM,EAAE,kBAAkB,CAAC;aAC9D,CAAC;SACH;QACD,OAAO,CAAC,CAAC;IACX,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import {AggregateOp} from 'vega';\nimport {BinParams} from './bin';\nimport {Data} from './data';\nimport {ImputeParams} from './impute';\nimport {LogicalOperand, normalizeLogicalOperand} from './logical';\nimport {normalizePredicate, Predicate} from './predicate';\nimport {SortField} from './sort';\nimport {TimeUnit} from './timeunit';\n\nexport interface FilterTransform {\n  /**\n   * The `filter` property must be one of the predicate definitions:\n   *\n   * 1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string,\n   * where `datum` can be used to refer to the current data object\n   *\n   * 2) one of the field predicates: [`equal`](https://vega.github.io/vega-lite/docs/filter.html#equal-predicate),\n   * [`lt`](https://vega.github.io/vega-lite/docs/filter.html#lt-predicate),\n   * [`lte`](https://vega.github.io/vega-lite/docs/filter.html#lte-predicate),\n   * [`gt`](https://vega.github.io/vega-lite/docs/filter.html#gt-predicate),\n   * [`gte`](https://vega.github.io/vega-lite/docs/filter.html#gte-predicate),\n   * [`range`](https://vega.github.io/vega-lite/docs/filter.html#range-predicate),\n   * [`oneOf`](https://vega.github.io/vega-lite/docs/filter.html#one-of-predicate),\n   * or [`valid`](https://vega.github.io/vega-lite/docs/filter.html#valid-predicate),\n   *\n   * 3) a [selection predicate](https://vega.github.io/vega-lite/docs/filter.html#selection-predicate)\n   *\n   * 4) a logical operand that combines (1), (2), or (3).\n   */\n  // TODO: https://github.com/vega/vega-lite/issues/2901\n  filter: LogicalOperand<Predicate>;\n}\n\nexport function isFilter(t: Transform): t is FilterTransform {\n  return t['filter'] !== undefined;\n}\n\nexport interface CalculateTransform {\n  /**\n   * A [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string. Use the variable `datum` to refer to the current data object.\n   */\n  calculate: string;\n\n  /**\n   * The field for storing the computed formula value.\n   */\n  as: string;\n}\n\nexport interface BinTransform {\n  /**\n   * An object indicating bin properties, or simply `true` for using default bin parameters.\n   */\n  bin: boolean | BinParams;\n\n  /**\n   * The data field to bin.\n   */\n  field: string;\n\n  /**\n   * The output fields at which to write the start and end bin values.\n   */\n  as: string | string[];\n}\n\nexport interface TimeUnitTransform {\n  /**\n   * The timeUnit.\n   */\n  timeUnit: TimeUnit;\n\n  /**\n   * The data field to apply time unit.\n   */\n  field: string;\n\n  /**\n   * The output field to write the timeUnit value.\n   */\n  as: string;\n}\n\nexport interface AggregateTransform {\n  /**\n   * Array of objects that define fields to aggregate.\n   */\n  aggregate: AggregatedFieldDef[];\n\n  /**\n   * The data fields to group by. If not specified, a single group containing all data objects will be used.\n   */\n  groupby?: string[];\n}\n\nexport interface AggregatedFieldDef {\n  /**\n   * The aggregation operations to apply to the fields, such as sum, average or count.\n   * See the [full list of supported aggregation operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops)\n   * for more information.\n   */\n  op: AggregateOp;\n\n  /**\n   * The data field for which to compute aggregate function. This is required for all aggregation operations except `\"count\"`.\n   */\n  field?: string;\n\n  /**\n   * The output field names to use for each aggregated field.\n   */\n  as: string;\n}\n\nexport interface StackTransform {\n  /**\n   * The field which is stacked.\n   */\n  stack: string;\n  /**\n   * The data fields to group by.\n   */\n  groupby: string[];\n  /**\n   * Mode for stacking marks.\n   * __Default value:__ `\"zero\"`\n   */\n  offset?: 'zero' | 'center' | 'normalize';\n  /**\n   * Field that determines the order of leaves in the stacked charts.\n   */\n  sort?: SortField[];\n  /**\n   * Output field names. This can be either a string or an array of strings with\n   * two elements denoting the name for the fields for stack start and stack end\n   * respectively.\n   * If a single string(eg.\"val\") is provided, the end field will be \"val_end\".\n   */\n  as: string | string[];\n}\n\nexport type WindowOnlyOp =\n  | 'row_number'\n  | 'rank'\n  | 'dense_rank'\n  | 'percent_rank'\n  | 'cume_dist'\n  | 'ntile'\n  | 'lag'\n  | 'lead'\n  | 'first_value'\n  | 'last_value'\n  | 'nth_value';\n\nexport interface WindowFieldDef {\n  /**\n   * The window or aggregation operations to apply within a window, including `rank`, `lead`, `sum`, `average` or `count`. See the list of all supported operations [here](https://vega.github.io/vega-lite/docs/window.html#ops).\n   */\n  op: AggregateOp | WindowOnlyOp;\n\n  /**\n   * Parameter values for the window functions. Parameter values can be omitted for operations that do not accept a parameter.\n   *\n   * See the list of all supported operations and their parameters [here](https://vega.github.io/vega-lite/docs/transforms/window.html).\n   */\n  param?: number;\n\n  /**\n   * The data field for which to compute the aggregate or window function. This can be omitted for window functions that do not operate over a field such as `count`, `rank`, `dense_rank`.\n   */\n  field?: string;\n\n  /**\n   * The output name for the window operation.\n   */\n  as: string;\n}\n\nexport interface WindowTransform {\n  /**\n   * The definition of the fields in the window, and what calculations to use.\n   */\n  window: WindowFieldDef[];\n\n  /**\n   * A frame specification as a two-element array indicating how the sliding window should proceed. The array entries should either be a number indicating the offset from the current data object, or null to indicate unbounded rows preceding or following the current data object. The default value is `[null, 0]`, indicating that the sliding window includes the current object and all preceding objects. The value `[-5, 5]` indicates that the window should include five objects preceding and five objects following the current object. Finally, `[null, null]` indicates that the window frame should always include all data objects. The only operators affected are the aggregation operations and the `first_value`, `last_value`, and `nth_value` window operations. The other window operations are not affected by this.\n   *\n   * __Default value:__:  `[null, 0]` (includes the current object and all preceding objects)\n   */\n  frame?: (null | number)[];\n\n  /**\n   * Indicates if the sliding window frame should ignore peer values. (Peer values are those considered identical by the sort criteria). The default is false, causing the window frame to expand to include all peer values. If set to true, the window frame will be defined by offset values only. This setting only affects those operations that depend on the window frame, namely aggregation operations and the first_value, last_value, and nth_value window operations.\n   *\n   * __Default value:__ `false`\n   */\n  ignorePeers?: boolean;\n\n  /**\n   * The data fields for partitioning the data objects into separate windows. If unspecified, all data points will be in a single group.\n   */\n  groupby?: string[];\n\n  /**\n   * A sort field definition for sorting data objects within a window. If two data objects are considered equal by the comparator, they are considered “peer” values of equal rank. If sort is not specified, the order is undefined: data objects are processed in the order they are observed and none are considered peers (the ignorePeers parameter is ignored and treated as if set to `true`).\n   */\n  sort?: SortField[];\n}\n\nexport interface ImputeSequence {\n  /**\n   * The starting value of the sequence.\n   * __Default value:__ `0`\n   */\n  start?: number;\n  /**\n   * The ending value(exclusive) of the sequence.\n   */\n  stop: number;\n  /**\n   * The step value between sequence entries.\n   * __Default value:__ `1` or `-1` if `stop < start`\n   */\n  step?: number;\n}\n\nexport function isImputeSequence(t: ImputeSequence | any[] | undefined): t is ImputeSequence {\n  return t && t['start'] !== undefined && t['stop'] !== undefined;\n}\n\nexport interface ImputeTransform extends ImputeParams {\n  /**\n   * The data field for which the missing values should be imputed.\n   */\n  impute: string;\n\n  /**\n   * A key field that uniquely identifies data objects within a group.\n   * Missing key values (those occurring in the data but not in the current group) will be imputed.\n   */\n  key: string;\n\n  /**\n   * An optional array of fields by which to group the values.\n   * Imputation will then be performed on a per-group basis.\n   */\n  groupby?: string[];\n}\n\nexport interface FlattenTransform {\n  /**\n   * An array of one or more data fields containing arrays to flatten.\n   * If multiple fields are specified, their array values should have a parallel structure, ideally with the same length.\n   * If the lengths of parallel arrays do not match,\n   * the longest array will be used with `null` values added for missing entries.\n   */\n  flatten: string[];\n\n  /**\n   * The output field names for extracted array values.\n   *\n   * __Default value:__ The field name of the corresponding array field\n   */\n  as?: string[];\n}\n\nexport interface SampleTransform {\n  /**\n   * The maximum number of data objects to include in the sample.\n   *\n   * __Default value:__ `1000`\n   */\n  sample: number;\n}\n\nexport interface LookupData {\n  /**\n   * Secondary data source to lookup in.\n   */\n  data: Data;\n  /**\n   * Key in data to lookup.\n   */\n  key: string;\n  /**\n   * Fields in foreign data to lookup.\n   * If not specified, the entire object is queried.\n   */\n  fields?: string[];\n}\n\nexport interface LookupTransform {\n  /**\n   * Key in primary data source.\n   */\n  lookup: string;\n\n  /**\n   * Secondary data reference.\n   */\n  from: LookupData;\n\n  /**\n   * The field or fields for storing the computed formula value.\n   * If `from.fields` is specified, the transform will use the same names for `as`.\n   * If `from.fields` is not specified, `as` has to be a string and we put the whole object into the data under the specified name.\n   */\n  as?: string | string[];\n\n  /**\n   * The default value to use if lookup fails.\n   *\n   * __Default value:__ `null`\n   */\n  default?: string;\n}\n\nexport interface FoldTransform {\n  /**\n   * An array of data fields indicating the properties to fold.\n   */\n  fold: string[];\n\n  /**\n   * The output field names for the key and value properties produced by the fold transform.\n   * __Default value:__ `[\"key\", \"value\"]`\n   */\n  as?: [string, string];\n}\n\nexport function isLookup(t: Transform): t is LookupTransform {\n  return t['lookup'] !== undefined;\n}\n\nexport function isSample(t: Transform): t is SampleTransform {\n  return t['sample'] !== undefined;\n}\n\nexport function isWindow(t: Transform): t is WindowTransform {\n  return t['window'] !== undefined;\n}\n\nexport function isFlatten(t: Transform): t is FlattenTransform {\n  return t['flatten'] !== undefined;\n}\nexport function isCalculate(t: Transform): t is CalculateTransform {\n  return t['calculate'] !== undefined;\n}\n\nexport function isBin(t: Transform): t is BinTransform {\n  return !!t['bin'];\n}\n\nexport function isImpute(t: Transform): t is ImputeTransform {\n  return t['impute'] !== undefined;\n}\n\nexport function isTimeUnit(t: Transform): t is TimeUnitTransform {\n  return t['timeUnit'] !== undefined;\n}\n\nexport function isAggregate(t: Transform): t is AggregateTransform {\n  return t['aggregate'] !== undefined;\n}\n\nexport function isStack(t: Transform): t is StackTransform {\n  return t['stack'] !== undefined;\n}\n\nexport function isFold(t: Transform): t is FoldTransform {\n  return t['fold'] !== undefined;\n}\n\nexport type Transform =\n  | FilterTransform\n  | CalculateTransform\n  | LookupTransform\n  | BinTransform\n  | TimeUnitTransform\n  | ImputeTransform\n  | AggregateTransform\n  | WindowTransform\n  | StackTransform\n  | FlattenTransform\n  | FoldTransform\n  | SampleTransform;\n\nexport function normalizeTransform(transform: Transform[]) {\n  return transform.map(t => {\n    if (isFilter(t)) {\n      return {\n        filter: normalizeLogicalOperand(t.filter, normalizePredicate)\n      };\n    }\n    return t;\n  });\n}\n"]}