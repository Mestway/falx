{"version":3,"file":"channel.js","sourceRoot":"","sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {Mark} from './mark';\nimport {FacetMapping} from './spec/facet';\nimport {Flag, flagKeys} from './util';\n\nexport namespace Channel {\n  // Facet\n  export const ROW: 'row' = 'row';\n  export const COLUMN: 'column' = 'column';\n\n  // Position\n  export const X: 'x' = 'x';\n  export const Y: 'y' = 'y';\n  export const X2: 'x2' = 'x2';\n  export const Y2: 'y2' = 'y2';\n  export const XERROR: 'xError' = 'xError';\n  export const YERROR: 'yError' = 'yError';\n  export const XERROR2: 'xError2' = 'xError2';\n  export const YERROR2: 'yError2' = 'yError2';\n\n  // Geo Position\n  export const LATITUDE: 'latitude' = 'latitude';\n  export const LONGITUDE: 'longitude' = 'longitude';\n  export const LATITUDE2: 'latitude2' = 'latitude2';\n  export const LONGITUDE2: 'longitude2' = 'longitude2';\n\n  // Mark property with scale\n  export const COLOR: 'color' = 'color';\n\n  export const FILL: 'fill' = 'fill';\n\n  export const STROKE: 'stroke' = 'stroke';\n\n  export const SHAPE: 'shape' = 'shape';\n  export const SIZE: 'size' = 'size';\n  export const OPACITY: 'opacity' = 'opacity';\n  export const FILLOPACITY: 'fillOpacity' = 'fillOpacity';\n\n  export const STROKEOPACITY: 'strokeOpacity' = 'strokeOpacity';\n\n  export const STROKEWIDTH: 'strokeWidth' = 'strokeWidth';\n\n  // Non-scale channel\n  export const TEXT: 'text' = 'text';\n  export const ORDER: 'order' = 'order';\n  export const DETAIL: 'detail' = 'detail';\n  export const KEY: 'key' = 'key';\n\n  export const TOOLTIP: 'tooltip' = 'tooltip';\n  export const HREF: 'href' = 'href';\n}\n\nexport type Channel = keyof Encoding<any> | keyof FacetMapping<any>;\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const X2 = Channel.X2;\nexport const Y2 = Channel.Y2;\nexport const XERROR = Channel.XERROR;\nexport const YERROR = Channel.YERROR;\nexport const XERROR2 = Channel.XERROR2;\nexport const YERROR2 = Channel.YERROR2;\n\nexport const LATITUDE = Channel.LATITUDE;\nexport const LATITUDE2 = Channel.LATITUDE2;\nexport const LONGITUDE = Channel.LONGITUDE;\nexport const LONGITUDE2 = Channel.LONGITUDE2;\n\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\n\nexport const FILL = Channel.FILL;\nexport const STROKE = Channel.STROKE;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const KEY = Channel.KEY;\nexport const ORDER = Channel.ORDER;\nexport const OPACITY = Channel.OPACITY;\nexport const FILLOPACITY = Channel.FILLOPACITY;\n\nexport const STROKEOPACITY = Channel.STROKEOPACITY;\n\nexport const STROKEWIDTH = Channel.STROKEWIDTH;\n\nexport const TOOLTIP = Channel.TOOLTIP;\nexport const HREF = Channel.HREF;\n\nexport type GeoPositionChannel = 'longitude' | 'latitude' | 'longitude2' | 'latitude2';\n\nexport const GEOPOSITION_CHANNEL_INDEX: Flag<GeoPositionChannel> = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\n\nexport const GEOPOSITION_CHANNELS = flagKeys(GEOPOSITION_CHANNEL_INDEX);\n\nconst UNIT_CHANNEL_INDEX: Flag<keyof Encoding<any>> = {\n  // position\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1,\n  xError: 1,\n  yError: 1,\n  xError2: 1,\n  yError2: 1,\n\n  ...GEOPOSITION_CHANNEL_INDEX,\n\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n\n  strokeWidth: 1,\n  size: 1,\n  shape: 1,\n\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1\n};\n\nexport type ColorChannel = 'color' | 'fill' | 'stroke';\n\nexport function isColorChannel(channel: Channel): channel is ColorChannel {\n  return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\n\nconst FACET_CHANNEL_INDEX: Flag<keyof FacetMapping<any>> = {\n  row: 1,\n  column: 1\n};\n\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\n\nexport const CHANNELS = flagKeys(CHANNEL_INDEX);\n\nconst {order: _o, detail: _d, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them.  Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\nexport const SINGLE_DEF_CHANNELS: SingleDefChannel[] = flagKeys(SINGLE_DEF_CHANNEL_INDEX);\n\n// Using the following line leads to TypeError: Cannot read property 'elementTypes' of undefined\n// when running the schema generator\n// export type SingleDefChannel = typeof SINGLE_DEF_CHANNELS[0];\nexport type SingleDefChannel =\n  | 'x'\n  | 'y'\n  | 'x2'\n  | 'y2'\n  | 'xError'\n  | 'yError'\n  | 'xError2'\n  | 'yError2'\n  | 'longitude'\n  | 'latitude'\n  | 'longitude2'\n  | 'latitude2'\n  | 'row'\n  | 'column'\n  | 'color'\n  | 'fill'\n  | 'stroke'\n  | 'strokeWidth'\n  | 'size'\n  | 'shape'\n  | 'fillOpacity'\n  | 'strokeOpacity'\n  | 'opacity'\n  | 'text'\n  | 'tooltip'\n  | 'href'\n  | 'key';\n\nexport function isChannel(str: string): str is Channel {\n  return !!CHANNEL_INDEX[str];\n}\n\nexport function isSecondaryRangeChannel(c: Channel): c is 'x2' | 'y2' | 'latitude2' | 'longitude2' {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n\nexport function getMainRangeChannel(channel: Channel): Channel {\n  switch (channel) {\n    case 'x2':\n      return 'x';\n    case 'y2':\n      return 'y';\n    case 'latitude2':\n      return 'latitude';\n    case 'longitude2':\n      return 'longitude';\n  }\n  return channel;\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = flagKeys(UNIT_CHANNEL_INDEX);\n\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  xError: _xError,\n  yError: _yError,\n  xError2: _xError2,\n  yError2: _yError2,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\n\nexport const NONPOSITION_CHANNELS = flagKeys(NONPOSITION_CHANNEL_INDEX);\nexport type NonPositionChannel = typeof NONPOSITION_CHANNELS[0];\n\n// POSITION_SCALE_CHANNELS = X and Y;\nconst POSITION_SCALE_CHANNEL_INDEX: {x: 1; y: 1} = {x: 1, y: 1};\nexport const POSITION_SCALE_CHANNELS = flagKeys(POSITION_SCALE_CHANNEL_INDEX);\nexport type PositionScaleChannel = typeof POSITION_SCALE_CHANNELS[0];\n\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = flagKeys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport type NonPositionScaleChannel = typeof NONPOSITION_SCALE_CHANNELS[0];\n\nexport function isNonPositionScaleChannel(channel: Channel): channel is NonPositionScaleChannel {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n\n/** List of channels with scales */\nexport const SCALE_CHANNELS = flagKeys(SCALE_CHANNEL_INDEX);\nexport type ScaleChannel = typeof SCALE_CHANNELS[0];\n\nexport function isScaleChannel(channel: Channel): channel is ScaleChannel {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n\nexport type SupportedMark = {[mark in Mark]?: 'always' | 'binned'};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return getSupportedMark(channel)[mark];\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    case ROW:\n    case COLUMN:\n      return {\n        // all marks\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        rect: 'always',\n        line: 'always',\n        trail: 'always',\n        area: 'always',\n        text: 'always',\n        geoshape: 'always'\n      };\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      return {\n        // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        rect: 'always',\n        line: 'always',\n        trail: 'always',\n        area: 'always',\n        text: 'always'\n      };\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        rule: 'always',\n        bar: 'always',\n        rect: 'always',\n        area: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned'\n      };\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n    case SHAPE:\n      return {point: 'always', geoshape: 'always'};\n    case TEXT:\n      return {text: 'always'};\n    case XERROR:\n    case YERROR:\n    case XERROR2:\n    case YERROR2:\n      return {};\n  }\n}\n\nexport function rangeType(channel: Channel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range.\n    case X2:\n    case Y2:\n    case XERROR:\n    case YERROR:\n    case XERROR2:\n    case YERROR2:\n      return undefined;\n\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    // TEXT, TOOLTIP, and HREF have no scale but have discrete output\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('rangeType not implemented for ' + channel);\n}\n"]}