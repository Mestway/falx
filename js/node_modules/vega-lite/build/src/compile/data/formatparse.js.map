{"version":3,"file":"formatparse.js","sourceRoot":"","sources":["../../../../src/compile/data/formatparse.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNumber, isString} from 'vega-util';\nimport {AncestorParse} from '.';\nimport {isMinMaxOp} from '../../aggregate';\nimport {getMainRangeChannel, SingleDefChannel} from '../../channel';\nimport {Parse} from '../../data';\nimport {DateTime, isDateTime} from '../../datetime';\nimport {isNumberFieldDef, isScaleFieldDef, isTimeFieldDef, isTypedFieldDef, TypedFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {forEachLeaf} from '../../logical';\nimport {isFieldEqualPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate} from '../../predicate';\nimport {isSortField} from '../../sort';\nimport {FilterTransform} from '../../transform';\nimport {accessPathDepth, accessPathWithDatum, duplicate, hash, keys, removePathFromField} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {Split} from '../split';\nimport {DataFlowNode} from './dataflow';\n\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field: string, parse: string): string {\n  const f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.indexOf('date:') === 0) {\n    const specifier = parse.slice(5, parse.length);\n    return `timeParse(${f},${specifier})`;\n  } else if (parse.indexOf('utc:') === 0) {\n    const specifier = parse.slice(4, parse.length);\n    return `utcParse(${f},${specifier})`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport class ParseNode extends DataFlowNode {\n  private _parse: Parse;\n\n  public clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n\n  constructor(parent: DataFlowNode, parse: Parse) {\n    super(parent);\n\n    this._parse = parse;\n  }\n\n  public hash() {\n    return `Parse ${hash(this._parse)}`;\n  }\n\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n  public static makeExplicit(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    // Custom parse\n    let explicit = {};\n    const data = model.data;\n    if (data && data.format && data.format.parse) {\n      explicit = data.format.parse;\n    }\n\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n\n  public static makeImplicitFromFilterTransform(\n    parent: DataFlowNode,\n    transform: FilterTransform,\n    ancestorParse: AncestorParse\n  ) {\n    const parse = {};\n    forEachLeaf(transform.filter, filter => {\n      if (isFieldPredicate(filter)) {\n        // Automatically add a parse node for filters with filter objects\n        let val: string | number | boolean | DateTime = null;\n\n        // For EqualFilter, just use the equal property.\n        // For RangeFilter and OneOfFilter, all array members should have\n        // the same type, so we only use the first one.\n        if (isFieldEqualPredicate(filter)) {\n          val = filter.equal;\n        } else if (isFieldRangePredicate(filter)) {\n          val = filter.range[0];\n        } else if (isFieldOneOfPredicate(filter)) {\n          val = (filter.oneOf || filter['in'])[0];\n        } // else -- for filter expression, we can't infer anything\n        if (val) {\n          if (isDateTime(val)) {\n            parse[filter.field] = 'date';\n          } else if (isNumber(val)) {\n            parse[filter.field] = 'number';\n          } else if (isString(val)) {\n            parse[filter.field] = 'string';\n          }\n        }\n\n        if (filter.timeUnit) {\n          parse[filter.field] = 'date';\n        }\n      }\n    });\n\n    if (keys(parse).length === 0) {\n      return null;\n    }\n\n    return this.makeWithAncestors(parent, {}, parse, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n   */\n  public static makeImplicitFromEncoding(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    const implicit = {};\n\n    function add(fieldDef: TypedFieldDef<string>) {\n      if (isTimeFieldDef(fieldDef)) {\n        implicit[fieldDef.field] = 'date';\n      } else if (isNumberFieldDef(fieldDef) && isMinMaxOp(fieldDef.aggregate)) {\n        implicit[fieldDef.field] = 'number';\n      } else if (accessPathDepth(fieldDef.field) > 1) {\n        // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n        // (Parsing numbers / dates already flattens numeric and temporal fields.)\n        if (!(fieldDef.field in implicit)) {\n          implicit[fieldDef.field] = 'flatten';\n        }\n      } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n        // Flatten fields that we sort by but that are not otherwise flattened.\n        if (!(fieldDef.sort.field in implicit)) {\n          implicit[fieldDef.sort.field] = 'flatten';\n        }\n      }\n    }\n\n    if (isUnitModel(model) || isFacetModel(model)) {\n      // Parse encoded fields\n      model.forEachFieldDef((fieldDef, channel) => {\n        if (isTypedFieldDef(fieldDef)) {\n          add(fieldDef);\n        } else {\n          const mainChannel = getMainRangeChannel(channel);\n          if (mainChannel !== channel) {\n            const mainFieldDef = model.fieldDef(mainChannel as SingleDefChannel) as TypedFieldDef<string>;\n            add({\n              ...fieldDef,\n              type: mainFieldDef.type\n            });\n          } else {\n            throw new Error(\n              `Non-secondary channel ${channel} must have type in its field definition ${JSON.stringify(fieldDef)}`\n            );\n          }\n        }\n      });\n    }\n    return this.makeWithAncestors(parent, {}, implicit, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n  private static makeWithAncestors(\n    parent: DataFlowNode,\n    explicit: Parse,\n    implicit: Parse,\n    ancestorParse: AncestorParse\n  ) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (\n          parsedAs.explicit ||\n          parsedAs.value === implicit[field] ||\n          parsedAs.value === 'derived' ||\n          implicit[field] === 'flatten'\n        ) {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n\n    const parse = new Split(explicit, implicit);\n\n    // add the format parse from this model so that children don't parse the same field again\n    ancestorParse.copyAll(parse);\n\n    // copy only non-null parses\n    const p = {};\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n\n    return new ParseNode(parent, p);\n  }\n\n  public get parse() {\n    return this._parse;\n  }\n\n  public merge(other: ParseNode) {\n    this._parse = {...this._parse, ...other.parse};\n    other.remove();\n  }\n\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n  public assembleFormatParse() {\n    const formatParse = {};\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n    return formatParse;\n  }\n\n  // format parse depends and produces all fields in its parse\n  public producedFields() {\n    return new Set(keys(this._parse));\n  }\n\n  public dependentFields() {\n    return new Set(keys(this._parse));\n  }\n\n  public assembleTransforms(onlyNested = false): VgFormulaTransform[] {\n    return keys(this._parse)\n      .filter(field => (onlyNested ? accessPathDepth(field) > 1 : true))\n      .map(field => {\n        const expr = parseExpression(field, this._parse[field]);\n        if (!expr) {\n          return null;\n        }\n\n        const formula: VgFormulaTransform = {\n          type: 'formula',\n          expr,\n          as: removePathFromField(field) // Vega output is always flattened\n        };\n        return formula;\n      })\n      .filter(t => t !== null);\n  }\n}\n"]}