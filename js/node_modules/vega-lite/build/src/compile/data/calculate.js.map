{"version":3,"file":"calculate.js","sourceRoot":"","sources":["../../../../src/compile/data/calculate.ts"],"names":[],"mappings":"AAEA,OAAO,EAAiB,eAAe,EAAiB,OAAO,EAAC,MAAM,gBAAgB,CAAC;AACvF,OAAO,EAAC,qBAAqB,EAAC,MAAM,iBAAiB,CAAC;AACtD,OAAO,EAAC,WAAW,EAAC,MAAM,YAAY,CAAC;AAEvC,OAAO,EAAC,SAAS,EAAE,IAAI,EAAC,MAAM,YAAY,CAAC;AAG3C,OAAO,EAAC,YAAY,EAAC,MAAM,YAAY,CAAC;AACxC,OAAO,EAAC,kBAAkB,EAAC,MAAM,eAAe,CAAC;AAEjD;;GAEG;AAEH,MAAM,OAAO,aAAc,SAAQ,YAAY;IAO7C,YAAY,MAAoB,EAAmB,SAA6B;QAC9E,KAAK,CAAC,MAAM,CAAC,CAAC;QADmC,cAAS,GAAT,SAAS,CAAoB;QAG9E,IAAI,CAAC,gBAAgB,GAAG,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IACvE,CAAC;IARM,KAAK;QACV,OAAO,IAAI,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IAC5D,CAAC;IAQM,MAAM,CAAC,oBAAoB,CAAC,MAAoB,EAAE,KAAqB;QAC5E,mDAAmD;QACnD,KAAK,CAAC,eAAe,CAAC,CAAC,QAA+B,EAAE,OAAyB,EAAE,EAAE;YACnF,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;gBAC9B,OAAO;aACR;YACD,IAAI,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBAC9B,MAAM,EAAC,KAAK,EAAE,QAAQ,EAAC,GAAG,QAAQ,CAAC;gBACnC,MAAM,IAAI,GAA6C,QAAQ,CAAC,IAAI,CAAC;gBACrE,iGAAiG;gBACjG,MAAM,SAAS,GACb,IAAI;qBACD,GAAG,CAAC,CAAC,SAAS,EAAE,CAAC,EAAE,EAAE;oBACpB,OAAO,GAAG,qBAAqB,CAAC,EAAC,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,EAAC,CAAC,MAAM,CAAC,KAAK,CAAC;gBACnF,CAAC,CAAC;qBACD,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;gBAE5B,MAAM,GAAG,IAAI,aAAa,CAAC,MAAM,EAAE;oBACjC,SAAS;oBACT,EAAE,EAAE,mBAAmB,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC;iBAC1D,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,cAAc;QACnB,OAAO,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;IACtC,CAAC;IAEM,eAAe;QACpB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAEM,QAAQ;QACb,OAAO;YACL,IAAI,EAAE,SAAS;YACf,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS;YAC9B,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE;SACtB,CAAC;IACJ,CAAC;IAEM,IAAI;QACT,OAAO,aAAa,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;IAC7C,CAAC;CACF;AAED,MAAM,UAAU,mBAAmB,CAAC,QAA+B,EAAE,OAAyB,EAAE,GAAoB;IAClH,OAAO,OAAO,CAAC,QAAQ,kBAAG,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,YAAY,IAAK,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,CAAC;AACpF,CAAC","sourcesContent":["import {SingleDefChannel} from '../../channel';\nimport {DateTime} from '../../datetime';\nimport {FieldRefOption, isScaleFieldDef, TypedFieldDef, vgField} from '../../fielddef';\nimport {fieldFilterExpression} from '../../predicate';\nimport {isSortArray} from '../../sort';\nimport {CalculateTransform} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {ModelWithField} from '../model';\nimport {DataFlowNode} from './dataflow';\nimport {getDependentFields} from './expressions';\n\n/**\n * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.\n */\n\nexport class CalculateNode extends DataFlowNode {\n  private _dependentFields: Set<string>;\n\n  public clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private readonly transform: CalculateTransform) {\n    super(parent);\n\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n\n  public static parseAllForSortIndex(parent: DataFlowNode, model: ModelWithField) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef: TypedFieldDef<string>, channel: SingleDefChannel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n      if (isSortArray(fieldDef.sort)) {\n        const {field, timeUnit} = fieldDef;\n        const sort: (number | string | boolean | DateTime)[] = fieldDef.sort;\n        // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n        const calculate =\n          sort\n            .map((sortValue, i) => {\n              return `${fieldFilterExpression({field, timeUnit, equal: sortValue})} ? ${i} : `;\n            })\n            .join('') + sort.length;\n\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {forAs: true})\n        });\n      }\n    });\n    return parent;\n  }\n\n  public producedFields() {\n    return new Set([this.transform.as]);\n  }\n\n  public dependentFields() {\n    return this._dependentFields;\n  }\n\n  public assemble(): VgFormulaTransform {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n\n  public hash() {\n    return `Calculate ${hash(this.transform)}`;\n  }\n}\n\nexport function sortArrayIndexField(fieldDef: TypedFieldDef<string>, channel: SingleDefChannel, opt?: FieldRefOption) {\n  return vgField(fieldDef, {prefix: channel, suffix: 'sort_index', ...(opt || {})});\n}\n"]}