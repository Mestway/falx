{"version":3,"file":"aggregate.js","sourceRoot":"","sources":["../../../../src/compile/data/aggregate.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp} from 'vega';\nimport {isBinning} from '../../bin';\nimport {Channel, isScaleChannel} from '../../channel';\nimport {binRequiresRange, FieldDef, isTypedFieldDef, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {AggregateTransform} from '../../transform';\nimport {Dict, duplicate, hash, keys, replacePathInField, setEqual} from '../../util';\nimport {VgAggregateTransform} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\ntype Measures = Dict<{[key in AggregateOp]?: Set<string>}>;\n\nfunction addDimension(dims: Set<string>, channel: Channel, fieldDef: FieldDef<string>) {\n  if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {binSuffix: 'end'}));\n\n    if (binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {binSuffix: 'range'}));\n    }\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Measures, childMeasures: Measures) {\n  for (const field of keys(childMeasures)) {\n    // when we merge a measure, we either have to add an aggregation operator or even a new field\n    const ops = childMeasures[field];\n    for (const op of keys(ops)) {\n      if (field in parentMeasures) {\n        // add operator to existing measure field\n        parentMeasures[field][op] = new Set([...(parentMeasures[field][op] || []), ...ops[op]]);\n      } else {\n        parentMeasures[field] = {[op]: ops[op]};\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  public clone() {\n    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(parent: DataFlowNode, private dimensions: Set<string>, private measures: Measures) {\n    super(parent);\n  }\n\n  get groupBy() {\n    return this.dimensions;\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas: Measures = {};\n    const dims = new Set<string>();\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      const {aggregate, field} = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = new Set([vgField(fieldDef, {forAs: true})]);\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][aggregate] = new Set([vgField(fieldDef, {forAs: true})]);\n\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field]['min'] = new Set([vgField({field, aggregate: 'min'}, {forAs: true})]);\n            meas[field]['max'] = new Set([vgField({field, aggregate: 'max'}, {forAs: true})]);\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef);\n      }\n    });\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: AggregateTransform): AggregateNode {\n    const dims = new Set<string>();\n    const meas: Measures = {};\n\n    for (const s of t.aggregate) {\n      const {op, field, as} = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = new Set([as ? as : vgField(s, {forAs: true})]);\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][op] = new Set([as ? as : vgField(s, {forAs: true})]);\n        }\n      }\n    }\n\n    for (const s of t.groupby || []) {\n      dims.add(s);\n    }\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public merge(other: AggregateNode): boolean {\n    if (setEqual(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      return true;\n    } else {\n      log.debug('different dimensions, cannot merge');\n      return false;\n    }\n  }\n\n  public addDimensions(fields: string[]) {\n    fields.forEach(this.dimensions.add, this.dimensions);\n  }\n\n  public dependentFields() {\n    return new Set([...this.dimensions, ...keys(this.measures)]);\n  }\n\n  public producedFields() {\n    const out = new Set<string>();\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        const m = this.measures[field][op];\n        if (m.size === 0) {\n          out.add(`${op}_${field}`);\n        } else {\n          m.forEach(out.add, out);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  public hash() {\n    return `Aggregate ${hash({dimensions: this.dimensions, measures: this.measures})}`;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: AggregateOp[] = [];\n    const fields: string[] = [];\n    const as: string[] = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        for (const alias of this.measures[field][op]) {\n          as.push(alias);\n          ops.push(op);\n          fields.push(replacePathInField(field));\n        }\n      }\n    }\n\n    const result: VgAggregateTransform = {\n      type: 'aggregate',\n      groupby: [...this.dimensions],\n      ops,\n      fields,\n      as\n    };\n\n    return result;\n  }\n}\n"]}