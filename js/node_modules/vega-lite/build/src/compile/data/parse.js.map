{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/data/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {Data, isInlineData, isNamedData, isUrlData, MAIN, ParseValue, RAW} from '../../data';\nimport * as log from '../../log';\nimport {\n  isAggregate,\n  isBin,\n  isCalculate,\n  isFilter,\n  isFlatten,\n  isFold,\n  isImpute,\n  isLookup,\n  isSample,\n  isStack,\n  isTimeUnit,\n  isWindow\n} from '../../transform';\nimport {deepEqual, mergeDeep} from '../../util';\nimport {isFacetModel, isLayerModel, isUnitModel, Model} from '../model';\nimport {requiresSelectionId} from '../selection/selection';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {ParseNode} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {AncestorParse, DataComponent} from './index';\nimport {LookupNode} from './lookup';\nimport {SampleTransformNode} from './sample';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\nimport {makeWindowFromFacet} from './windowfacet';\n\nexport function findSource(data: Data, sources: SourceNode[]) {\n  for (const other of sources) {\n    const otherData = other.data;\n    if (isInlineData(data) && isInlineData(otherData)) {\n      const srcVals = data.values;\n      const otherVals = otherData.values;\n      if (deepEqual(srcVals, otherVals)) {\n        return other;\n      }\n    } else if (isUrlData(data) && isUrlData(otherData)) {\n      if (data.url === otherData.url) {\n        return other;\n      }\n    } else if (isNamedData(data)) {\n      if (data.name === other.dataName) {\n        return other;\n      }\n    }\n  }\n  return null;\n}\n\nfunction parseRoot(model: Model, sources: SourceNode[]): DataFlowNode {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n\n    const existingSource = findSource(model.data, sources);\n\n    if (existingSource) {\n      existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);\n\n      return existingSource;\n    } else {\n      const source = new SourceNode(model.data);\n      sources.push(source);\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot\n      ? model.parent.component.data.facetRoot\n      : model.parent.component.data.main;\n  }\n}\n\n/**\n * Parses a transforms array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(head: DataFlowNode, model: Model, ancestorParse: AncestorParse): DataFlowNode {\n  let lookupCounter = 0;\n\n  for (const t of model.transforms) {\n    let derivedType: ParseValue = undefined;\n    let transformNode: DataFlowNode;\n\n    if (isCalculate(t)) {\n      transformNode = head = new CalculateNode(head, t);\n      derivedType = 'derived';\n    } else if (isFilter(t)) {\n      transformNode = head = ParseNode.makeImplicitFromFilterTransform(head, t, ancestorParse) || head;\n\n      head = new FilterNode(head, model, t.filter);\n    } else if (isBin(t)) {\n      transformNode = head = BinNode.makeFromTransform(head, t, model);\n      derivedType = 'number';\n    } else if (isTimeUnit(t)) {\n      transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n      derivedType = 'date';\n\n      // Create parse node because the input to time unit is always date.\n      const parsedAs = ancestorParse.getWithExplicit(t.field);\n      if (parsedAs.value === undefined) {\n        head = new ParseNode(head, {[t.field]: derivedType});\n        ancestorParse.set(t.field, derivedType, false);\n      }\n    } else if (isAggregate(t)) {\n      transformNode = head = AggregateNode.makeFromTransform(head, t);\n      derivedType = 'number';\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    } else if (isLookup(t)) {\n      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n      derivedType = 'derived';\n    } else if (isWindow(t)) {\n      transformNode = head = new WindowTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isStack(t)) {\n      transformNode = head = StackNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isFold(t)) {\n      transformNode = head = new FoldTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isFlatten(t)) {\n      transformNode = head = new FlattenTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isSample(t)) {\n      head = new SampleTransformNode(head, t);\n    } else if (isImpute(t)) {\n      transformNode = head = ImputeNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      continue;\n    }\n\n    if (transformNode && derivedType !== undefined) {\n      for (const field of transformNode.producedFields()) {\n        ancestorParse.set(field, derivedType, false);\n      }\n    }\n  }\n\n  return head;\n}\n\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\n\nexport function parseData(model: Model): DataComponent {\n  let head = parseRoot(model, model.component.data.sources);\n\n  const {outputNodes, outputNodeRefCounts} = model.component.data;\n  const ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n\n  // format.parse: null means disable parsing\n  if (model.data && model.data.format && model.data.format.parse === null) {\n    ancestorParse.parseNothing = true;\n  }\n\n  head = ParseNode.makeExplicit(head, model, ancestorParse) || head;\n\n  // Default discrete selections require an identifier transform to\n  // uniquely identify data points as the _id field is volatile. Add\n  // this transform at the head of our pipeline such that the identifier\n  // field is available for all subsequent datasets. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n  if (requiresSelectionId(model) && (isUnitModel(model) || isLayerModel(model))) {\n    head = new IdentifierNode(head);\n  }\n\n  // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n  const parentIsLayer = model.parent && isLayerModel(model.parent);\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) || head;\n    }\n  }\n\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  }\n\n  head = ParseNode.makeImplicitFromEncoding(head, model, ancestorParse) || head;\n\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (!parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) || head;\n    }\n\n    head = TimeUnitNode.makeFromEncoding(head, model) || head;\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  }\n\n  // add an output node pre aggregation\n  const rawName = model.getName(RAW);\n  const raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n\n  if (isUnitModel(model)) {\n    const agg = AggregateNode.makeFromEncoding(head, model);\n    if (agg) {\n      head = agg;\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n    head = ImputeNode.makeFromEncoding(head, model) || head;\n    head = StackNode.makeFromEncoding(head, model) || head;\n  }\n\n  // output node for marks\n  const mainName = model.getName(MAIN);\n  const main = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n\n  // add facet marker\n  let facetRoot = null;\n  if (isFacetModel(model)) {\n    const facetName = model.getName('facet');\n\n    // Derive new sort index field for facet's sort array\n    head = CalculateNode.parseAllForSortIndex(head, model);\n\n    // Derive new aggregate (via window) for facet's sort field\n    // TODO: use JoinAggregate once we have it\n    // augment data source with new fields for crossed facet\n    head = makeWindowFromFacet(head, model.facet) || head;\n\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n    head = facetRoot;\n  }\n  return {\n    ...model.component.data,\n    outputNodes,\n    outputNodeRefCounts,\n    raw,\n    main,\n    facetRoot,\n    ancestorParse\n  };\n}\n"]}