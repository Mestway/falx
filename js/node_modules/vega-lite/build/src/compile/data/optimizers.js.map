{"version":3,"file":"optimizers.js","sourceRoot":"","sources":["../../../../src/compile/data/optimizers.ts"],"names":[],"mappings":"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","sourcesContent":["import {MAIN} from '../../data';\nimport {Dict, fieldIntersection, flatten, hash, hasIntersection, keys} from '../../util';\nimport {AggregateNode} from './aggregate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {FACET_SCALE_PREFIX} from './optimize';\nimport {BottomUpOptimizer, TopDownOptimizer} from './optimizer';\nimport * as optimizers from './optimizers';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nexport interface OptimizerFlags {\n  /**\n   * If true, iteration continues\n   */\n  continueFlag: boolean;\n  /**\n   * If true, the tree has been mutated by the function\n   */\n  mutatedFlag: boolean;\n}\n\n/**\n * Start optimization path at the leaves. Useful for merging up or removing things.\n *\n * If the callback returns true, the recursion continues.\n */\nexport function iterateFromLeaves(f: (node: DataFlowNode) => OptimizerFlags) {\n  function optimizeNextFromLeaves(node: DataFlowNode): boolean {\n    if (node instanceof SourceNode) {\n      return false;\n    }\n\n    const next = node.parent;\n    const {continueFlag, mutatedFlag} = f(node);\n    let childFlag = false;\n    if (continueFlag) {\n      childFlag = optimizeNextFromLeaves(next);\n    }\n    return mutatedFlag || childFlag;\n  }\n\n  return optimizeNextFromLeaves;\n}\n\n/**\n * Move parse nodes up to forks.\n */\nexport class MoveParseUp extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    const parent = node.parent;\n    // move parse up by merging or swapping\n    if (node instanceof ParseNode) {\n      if (parent instanceof SourceNode) {\n        return this.flags;\n      }\n\n      if (parent.numChildren() > 1) {\n        // don't move parse further up but continue with parent.\n        this.setContinue();\n        return this.flags;\n      }\n\n      if (parent instanceof ParseNode) {\n        this.setMutated();\n        parent.merge(node);\n      } else {\n        // don't swap with nodes that produce something that the parse node depends on (e.g. lookup)\n        if (fieldIntersection(parent.producedFields(), node.dependentFields())) {\n          this.setContinue();\n          return this.flags;\n        }\n        this.setMutated();\n        node.swapWithParent();\n      }\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n  public mergeNodes(parent: DataFlowNode, nodes: DataFlowNode[]) {\n    const mergedNode = nodes.shift();\n    for (const node of nodes) {\n      parent.removeChild(node);\n      node.parent = mergedNode;\n      node.remove();\n    }\n  }\n\n  public run(node: DataFlowNode): boolean {\n    const hashes = node.children.map(x => x.hash());\n    const buckets: {hash?: DataFlowNode[]} = {};\n\n    for (let i = 0; i < hashes.length; i++) {\n      if (buckets[hashes[i]] === undefined) {\n        buckets[hashes[i]] = [node.children[i]];\n      } else {\n        buckets[hashes[i]].push(node.children[i]);\n      }\n    }\n\n    for (const k of keys(buckets)) {\n      if (buckets[k].length > 1) {\n        this.setMutated();\n        this.mergeNodes(node, buckets[k]);\n      }\n    }\n    for (const child of node.children) {\n      this.run(child);\n    }\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n      // no need to continue with parent because it is output node or will have children (there was a fork)\n      return this.flags;\n    } else {\n      this.setMutated();\n      node.remove();\n    }\n    return this.flags;\n  }\n}\n\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n */\n\nexport class RemoveDuplicateTimeUnits extends BottomUpOptimizer {\n  private fields = new Set<string>();\n  public run(node: DataFlowNode): OptimizerFlags {\n    this.setContinue();\n    if (node instanceof TimeUnitNode) {\n      const pfields = node.producedFields();\n      if (hasIntersection(pfields, this.fields)) {\n        this.setMutated();\n        node.remove();\n      } else {\n        this.fields = new Set([...this.fields, ...pfields]);\n      }\n    }\n    return this.flags;\n  }\n}\n\n/**\n * Clones the subtree and ignores output nodes except for the leaves, which are renamed.\n */\nfunction cloneSubtree(facet: FacetNode) {\n  function clone(node: DataFlowNode): DataFlowNode[] {\n    if (!(node instanceof FacetNode)) {\n      const copy = node.clone();\n\n      if (copy instanceof OutputNode) {\n        const newName = FACET_SCALE_PREFIX + copy.getSource();\n        copy.setSource(newName);\n\n        facet.model.component.data.outputNodes[newName] = copy;\n      } else if (copy instanceof AggregateNode || copy instanceof StackNode || copy instanceof WindowTransformNode) {\n        copy.addDimensions(facet.fields);\n      }\n      flatten(node.children.map(clone)).forEach((n: DataFlowNode) => (n.parent = copy));\n\n      return [copy];\n    }\n\n    return flatten(node.children.map(clone));\n  }\n  return clone;\n}\n\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\nexport function moveFacetDown(node: DataFlowNode) {\n  if (node instanceof FacetNode) {\n    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {\n      // move down until we hit a fork or output node\n      const child = node.children[0];\n\n      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode) {\n        child.addDimensions(node.fields);\n      }\n\n      child.swapWithParent();\n      moveFacetDown(node);\n    } else {\n      // move main to facet\n\n      const facetMain = node.model.component.data.main;\n      moveMainDownToFacet(facetMain);\n\n      // replicate the subtree and place it before the facet's main node\n      const cloner = cloneSubtree(node);\n      const copy: DataFlowNode[] = flatten(node.children.map(cloner));\n      for (const c of copy) {\n        c.parent = facetMain;\n      }\n    }\n  } else {\n    node.children.map(moveFacetDown);\n  }\n}\n\nfunction moveMainDownToFacet(node: DataFlowNode) {\n  if (node instanceof OutputNode && node.type === MAIN) {\n    if (node.numChildren() === 1) {\n      const child = node.children[0];\n      if (!(child instanceof FacetNode)) {\n        child.swapWithParent();\n        moveMainDownToFacet(node);\n      }\n    }\n  }\n}\n\n/**\n * Remove nodes that are not required starting from a root.\n */\nexport class RemoveUnnecessaryNodes extends TopDownOptimizer {\n  public run(node: DataFlowNode): boolean {\n    // remove output nodes that are not required\n    if (node instanceof OutputNode && !node.isRequired()) {\n      this.setMutated();\n      node.remove();\n    }\n    for (const child of node.children) {\n      this.run(child);\n    }\n\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * Inserts an Intermediate ParseNode containing all non-conflicting Parse fields and removes the empty ParseNodes\n */\nexport class MergeParse extends BottomUpOptimizer {\n  public run(node: DataFlowNode): optimizers.OptimizerFlags {\n    const parent = node.parent;\n    const parseChildren = parent.children.filter((x): x is ParseNode => x instanceof ParseNode);\n\n    if (parseChildren.length > 1) {\n      const commonParse = {};\n      for (const parseNode of parseChildren) {\n        const parse = parseNode.parse;\n        for (const k of keys(parse)) {\n          if (commonParse[k] === undefined) {\n            commonParse[k] = parse[k];\n          } else if (commonParse[k] !== parse[k]) {\n            delete commonParse[k];\n          }\n        }\n      }\n      if (keys(commonParse).length !== 0) {\n        this.setMutated();\n        const mergedParseNode = new ParseNode(parent, commonParse);\n        for (const parseNode of parseChildren) {\n          for (const key of keys(commonParse)) {\n            delete parseNode.parse[key];\n          }\n          parent.removeChild(parseNode);\n          parseNode.parent = mergedParseNode;\n          if (keys(parseNode.parse).length === 0) {\n            parseNode.remove();\n          }\n        }\n      }\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n\nexport class MergeAggregateNodes extends BottomUpOptimizer {\n  public run(node: DataFlowNode): optimizers.OptimizerFlags {\n    const parent = node.parent;\n    const aggChildren = parent.children.filter((x): x is AggregateNode => x instanceof AggregateNode);\n\n    // Object which we'll use to map the fields which an aggregate is grouped by to\n    // the set of aggregates with that grouping. This is useful as only aggregates\n    // with the same group by can be merged\n    const groupedAggregates: Dict<AggregateNode[]> = {};\n\n    // Build groupedAggregates\n    for (const agg of aggChildren) {\n      const groupBys = hash(keys(agg.groupBy).sort());\n      if (!(groupBys in groupedAggregates)) {\n        groupedAggregates[groupBys] = [];\n      }\n      groupedAggregates[groupBys].push(agg);\n    }\n\n    // Merge aggregateNodes with same key in groupedAggregates\n    for (const group of keys(groupedAggregates)) {\n      const mergeableAggs = groupedAggregates[group];\n      if (mergeableAggs.length > 1) {\n        const mergedAggs = mergeableAggs.pop();\n        for (const agg of mergeableAggs) {\n          if (mergedAggs.merge(agg)) {\n            parent.removeChild(agg);\n            agg.parent = mergedAggs;\n            agg.remove();\n\n            this.setMutated();\n          }\n        }\n      }\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n"]}