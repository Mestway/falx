{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/compile/header/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utility for generating row / column headers\n */\nimport {Axis as VgAxis, AxisOrient, TitleConfig as VgTitleConfig} from 'vega';\nimport {isArray} from 'vega-util';\nimport {Config} from '../../config';\nimport {vgField} from '../../fielddef';\nimport {\n  HEADER_LABEL_PROPERTIES,\n  HEADER_LABEL_PROPERTIES_MAP,\n  HEADER_TITLE_PROPERTIES,\n  HEADER_TITLE_PROPERTIES_MAP,\n  HeaderConfig\n} from '../../header';\nimport {isSortField} from '../../sort';\nimport {FacetFieldDef} from '../../spec/facet';\nimport {keys} from '../../util';\nimport {VgComparator, VgMarkGroup} from '../../vega.schema';\nimport {formatSignalRef} from '../common';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {Model} from '../model';\n\nexport type HeaderChannel = 'row' | 'column';\nexport const HEADER_CHANNELS: HeaderChannel[] = ['row', 'column'];\n\nexport type HeaderType = 'header' | 'footer';\nexport const HEADER_TYPES: HeaderType[] = ['header', 'footer'];\n\n/**\n * A component that represents all header, footers and title of a Vega group with layout directive.\n */\nexport interface LayoutHeaderComponent {\n  title?: string;\n\n  // TODO: repeat and concat can have multiple header / footer.\n  // Need to redesign this part a bit.\n\n  facetFieldDef?: FacetFieldDef<string>;\n\n  /**\n   * An array of header components for headers.\n   * For facet, there should be only one header component, which is data-driven.\n   * For repeat and concat, there can be multiple header components that explicitly list different axes.\n   */\n  header?: HeaderComponent[];\n\n  /**\n   * An array of header components for footers.\n   * For facet, there should be only one header component, which is data-driven.\n   * For repeat and concat, there can be multiple header components that explicitly list different axes.\n   */\n  footer?: HeaderComponent[];\n}\n\n/**\n * A component that represents one group of row/column-header/footer.\n */\nexport interface HeaderComponent {\n  labels: boolean;\n\n  sizeSignal: {signal: string};\n\n  axes: VgAxis[];\n}\n\nexport function getHeaderType(orient: AxisOrient) {\n  if (orient === 'top' || orient === 'left') {\n    return 'header';\n  }\n  return 'footer';\n}\n\nexport function getTitleGroup(model: Model, channel: HeaderChannel) {\n  const title = model.component.layoutHeaders[channel].title;\n  const config = model.config ? model.config : undefined;\n  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef\n    ? model.component.layoutHeaders[channel].facetFieldDef\n    : undefined;\n\n  return {\n    name: `${channel}-title`,\n    type: 'group',\n    role: `${channel}-title`,\n    title: {\n      text: title,\n      offset: 10,\n      ...(channel === 'row' ? {orient: 'left'} : {}),\n      style: 'guide-title',\n      ...getHeaderProperties(config, facetFieldDef, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)\n    }\n  };\n}\n\nexport function getHeaderGroups(model: Model, channel: HeaderChannel): VgMarkGroup[] {\n  const layoutHeader = model.component.layoutHeaders[channel];\n  const groups = [];\n  for (const headerType of HEADER_TYPES) {\n    if (layoutHeader[headerType]) {\n      for (const headerCmpt of layoutHeader[headerType]) {\n        groups.push(getHeaderGroup(model, channel, headerType, layoutHeader, headerCmpt));\n      }\n    }\n  }\n  return groups;\n}\n\n// 0, (0,90), 90, (90, 180), 180, (180, 270), 270, (270, 0)\n\nexport function labelAlign(angle: number) {\n  // to keep angle in [0, 360)\n  angle = ((angle % 360) + 360) % 360;\n  if ((angle + 90) % 180 === 0) {\n    // for 90 and 270\n    return {}; // default center\n  } else if (angle < 90 || 270 < angle) {\n    return {align: {value: 'right'}};\n  } else if (135 <= angle && angle < 225) {\n    return {align: {value: 'left'}};\n  }\n  return {};\n}\n\nexport function labelBaseline(angle: number) {\n  // to keep angle in [0, 360)\n  angle = ((angle % 360) + 360) % 360;\n  if (45 <= angle && angle <= 135) {\n    return {baseline: 'top'};\n  }\n  return {baseline: 'middle'};\n}\n\nfunction getSort(facetFieldDef: FacetFieldDef<string>, channel: 'row' | 'column'): VgComparator {\n  const {sort} = facetFieldDef;\n  if (isSortField(sort)) {\n    return {\n      field: vgField(sort, {expr: 'datum'}),\n      order: sort.order || 'ascending'\n    };\n  } else if (isArray(sort)) {\n    return {\n      field: sortArrayIndexField(facetFieldDef, channel, {expr: 'datum'}),\n      order: 'ascending'\n    };\n  } else {\n    return {\n      field: vgField(facetFieldDef, {expr: 'datum'}),\n      order: sort || 'ascending'\n    };\n  }\n}\n\nexport function getHeaderGroup(\n  model: Model,\n  channel: HeaderChannel,\n  headerType: HeaderType,\n  layoutHeader: LayoutHeaderComponent,\n  headerCmpt: HeaderComponent\n) {\n  if (headerCmpt) {\n    let title = null;\n    const {facetFieldDef} = layoutHeader;\n    if (facetFieldDef && headerCmpt.labels) {\n      const {header = {}} = facetFieldDef;\n      const {format, labelAngle} = header;\n      const config = model.config ? model.config : undefined;\n\n      const update = {\n        ...labelAlign(labelAngle)\n      };\n\n      title = {\n        text: formatSignalRef(facetFieldDef, format, 'parent', model.config),\n        offset: 10,\n        ...(channel === 'row' ? {orient: 'left'} : {}),\n        style: 'guide-label',\n        ...(labelAngle !== undefined ? {angle: labelAngle} : {}),\n        ...labelBaseline(labelAngle),\n        ...getHeaderProperties(config, facetFieldDef, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP),\n        ...(keys(update).length > 0 ? {encode: {update}} : {})\n      };\n    }\n\n    const axes = headerCmpt.axes;\n\n    const hasAxes = axes && axes.length > 0;\n    if (title || hasAxes) {\n      const sizeChannel = channel === 'row' ? 'height' : 'width';\n\n      return {\n        name: model.getName(`${channel}_${headerType}`),\n        type: 'group',\n        role: `${channel}-${headerType}`,\n        ...(layoutHeader.facetFieldDef\n          ? {\n              from: {data: model.getName(channel + '_domain')},\n              sort: getSort(facetFieldDef, channel)\n            }\n          : {}),\n        ...(title ? {title} : {}),\n        ...(headerCmpt.sizeSignal\n          ? {\n              encode: {\n                update: {\n                  [sizeChannel]: headerCmpt.sizeSignal\n                }\n              }\n            }\n          : {}),\n        ...(hasAxes ? {axes} : {})\n      };\n    }\n  }\n  return null;\n}\n\nexport function getHeaderProperties(\n  config: Config,\n  facetFieldDef: FacetFieldDef<string>,\n  properties: (keyof HeaderConfig)[],\n  propertiesMap: {[k in keyof HeaderConfig]: keyof VgTitleConfig}\n) {\n  const props = {};\n  for (const prop of properties) {\n    if (config && config.header) {\n      if (config.header[prop]) {\n        props[propertiesMap[prop]] = config.header[prop];\n      }\n    }\n    if (facetFieldDef && facetFieldDef.header) {\n      if (facetFieldDef.header[prop]) {\n        props[propertiesMap[prop]] = facetFieldDef.header[prop];\n      }\n    }\n  }\n  return props;\n}\n"]}