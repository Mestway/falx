{"version":3,"file":"properties.js","sourceRoot":"","sources":["../../../../src/compile/axis/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {Align, AxisOrient, SignalRef} from 'vega';\nimport {Axis} from '../../axis';\nimport {isBinning} from '../../bin';\nimport {PositionScaleChannel, X, Y} from '../../channel';\nimport {TypedFieldDef, valueArray, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {hasDiscreteDomain, isSelectionDomain, ScaleType} from '../../scale';\nimport {NOMINAL, ORDINAL, QUANTITATIVE} from '../../type';\nimport {contains} from '../../util';\nimport {UnitModel} from '../unit';\nimport {getAxisConfig} from './config';\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function defaultGrid(scaleType: ScaleType, fieldDef: TypedFieldDef<string>) {\n  return !hasDiscreteDomain(scaleType) && !isBinning(fieldDef.bin);\n}\n\nexport function gridScale(model: UnitModel, channel: PositionScaleChannel) {\n  const gridChannel: PositionScaleChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\n\nexport function labelAngle(\n  model: UnitModel,\n  specifiedAxis: Axis,\n  channel: PositionScaleChannel,\n  fieldDef: TypedFieldDef<string>\n) {\n  // try axis value\n  if (specifiedAxis.labelAngle !== undefined) {\n    // Make angle within [0,360)\n    return ((specifiedAxis.labelAngle % 360) + 360) % 360;\n  } else {\n    // try axis config value\n    const angle = getAxisConfig(\n      'labelAngle',\n      model.config,\n      channel,\n      orient(channel),\n      model.getScaleComponent(channel).get('type')\n    );\n    if (angle !== undefined) {\n      return ((angle % 360) + 360) % 360;\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldDef.type)) {\n        return 270;\n      }\n      // no default\n      return undefined;\n    }\n  }\n}\n\nexport function defaultLabelBaseline(angle: number, axisOrient: AxisOrient) {\n  if (angle !== undefined) {\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle <= 45 || 315 <= angle) {\n        return axisOrient === 'top' ? 'bottom' : 'top';\n      } else if (135 <= angle && angle <= 225) {\n        return axisOrient === 'top' ? 'top' : 'bottom';\n      } else {\n        return 'middle';\n      }\n    } else {\n      if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n        return 'middle';\n      } else if (45 <= angle && angle <= 135) {\n        return axisOrient === 'left' ? 'top' : 'bottom';\n      } else {\n        return axisOrient === 'left' ? 'bottom' : 'top';\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function defaultLabelAlign(angle: number, axisOrient: AxisOrient): Align {\n  if (angle !== undefined) {\n    angle = ((angle % 360) + 360) % 360;\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle % 180 === 0) {\n        return 'center';\n      } else if (0 < angle && angle < 180) {\n        return axisOrient === 'top' ? 'right' : 'left';\n      } else {\n        return axisOrient === 'top' ? 'left' : 'right';\n      }\n    } else {\n      if ((angle + 90) % 180 === 0) {\n        return 'center';\n      } else if (90 <= angle && angle < 270) {\n        return axisOrient === 'left' ? 'left' : 'right';\n      } else {\n        return axisOrient === 'left' ? 'right' : 'left';\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function defaultLabelFlush(fieldDef: TypedFieldDef<string>, channel: PositionScaleChannel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], fieldDef.type)) {\n    return true;\n  }\n  return undefined;\n}\n\nexport function defaultLabelOverlap(fieldDef: TypedFieldDef<string>, scaleType: ScaleType) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (fieldDef.type !== 'nominal') {\n    if (scaleType === 'log') {\n      return 'greedy';\n    }\n    return true;\n  }\n  return undefined;\n}\n\nexport function orient(channel: PositionScaleChannel) {\n  switch (channel) {\n    case X:\n      return 'bottom';\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function defaultTickCount({\n  fieldDef,\n  scaleType,\n  size,\n  scaleName,\n  specifiedAxis = {}\n}: {\n  fieldDef: TypedFieldDef<string>;\n  scaleType: ScaleType;\n  size?: SignalRef;\n  scaleName?: string;\n  specifiedAxis?: Axis;\n}) {\n  if (\n    !hasDiscreteDomain(scaleType) &&\n    scaleType !== 'log' &&\n    !contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)\n  ) {\n    if (specifiedAxis.tickStep) {\n      return {signal: `(domain('${scaleName}')[1] - domain('${scaleName}')[0]) / ${specifiedAxis.tickStep} + 1`};\n    } else if (isBinning(fieldDef.bin)) {\n      // for binned data, we don't want more ticks than maxbins\n      return {signal: `ceil(${size.signal}/10)`};\n    }\n    return {signal: `ceil(${size.signal}/40)`};\n  }\n\n  return undefined;\n}\n\nexport function values(\n  specifiedAxis: Axis,\n  model: UnitModel,\n  fieldDef: TypedFieldDef<string>,\n  channel: PositionScaleChannel\n) {\n  const vals = specifiedAxis.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    if (isBinning(fieldDef.bin)) {\n      const domain = model.scaleDomain(channel);\n      if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n        // explicit value\n        return vals;\n      }\n      const binSignal = model.getName(vgField(fieldDef, {suffix: 'bins'}));\n      return {signal: `sequence(${binSignal}.start, ${binSignal}.stop + ${binSignal}.step, ${binSignal}.step)`};\n    } else if (specifiedAxis.tickStep) {\n      const scaleName = model.scaleName(channel);\n      const step = specifiedAxis.tickStep;\n      return {signal: `sequence(domain('${scaleName}')[0], domain('${scaleName}')[1] + ${step}, ${step})`};\n    }\n  }\n\n  return undefined;\n}\n"]}