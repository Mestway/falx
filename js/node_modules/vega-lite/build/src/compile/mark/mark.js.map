{"version":3,"file":"mark.js","sourceRoot":"","sources":["../../../../src/compile/mark/mark.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {MAIN} from '../../data';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {getTypedFieldDef, isFieldDef, isValueDef, vgField} from '../../fielddef';\nimport {AREA, isPathMark, LINE, Mark, TRAIL} from '../../mark';\nimport {isSortField} from '../../sort';\nimport {contains, getFirstDefined, keys} from '../../util';\nimport {VgCompare} from '../../vega.schema';\nimport {getStyles, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nconst markCompiler: {[m in Mark]: MarkCompiler} = {\n  area,\n  bar,\n  circle,\n  geoshape,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroup(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model: UnitModel) {\n  const details = pathGroupingFields(model.mark, model.encoding);\n\n  const pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ''\n  });\n\n  if (details.length > 0) {\n    // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [\n      {\n        name: model.getName('pathgroup'),\n        type: 'group',\n        from: {\n          facet: {\n            name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n            data: model.requestDataName(MAIN),\n            groupby: details\n          }\n        },\n        encode: {\n          update: {\n            width: {field: {group: 'width'}},\n            height: {field: {group: 'height'}}\n          }\n        },\n        marks: pathMarks\n      }\n    ];\n  } else {\n    return pathMarks;\n  }\n}\n\nexport function getSort(model: UnitModel): VgCompare {\n  const {encoding, stack, mark, markDef} = model;\n  const order = encoding.order;\n  if (!isArray(order) && isValueDef(order)) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannelDef = encoding[markDef.orient === 'horizontal' ? 'y' : 'x'];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n      const sortField = isSortField(s)\n        ? vgField(\n            {\n              // FIXME: this op might not already exist?\n              // FIXME: what if dimensionChannel (x or y) contains custom domain?\n              aggregate: isAggregate(model.encoding) ? s.op : undefined,\n              field: s.field\n            },\n            {expr: 'datum'}\n          )\n        : vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n            expr: 'datum'\n          });\n\n      return {\n        field: sortField,\n        order: 'descending'\n      };\n    }\n    return undefined;\n  }\n  return undefined;\n}\n\nfunction getMarkGroups(\n  model: UnitModel,\n  opt: {\n    fromPrefix: string;\n  } = {fromPrefix: ''}\n) {\n  const mark = model.mark;\n\n  const clip = getFirstDefined(model.markDef.clip, scaleClip(model));\n  const style = getStyles(model.markDef);\n  const key = model.encoding.key;\n  const sort = getSort(model);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform\n    ? markCompiler[mark].postEncodingTransform(model)\n    : null;\n\n  return [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      ...(clip ? {clip: true} : {}),\n      ...(style ? {style} : {}),\n      ...(key ? {key: {field: key.field}} : {}),\n      ...(sort ? {sort} : {}),\n      from: {data: opt.fromPrefix + model.requestDataName(MAIN)},\n      encode: {\n        update: markCompiler[mark].encodeEntry(model)\n      },\n      ...(postEncodingTransform\n        ? {\n            transform: postEncodingTransform\n          }\n        : {})\n    }\n  ];\n}\n\n/**\n * Returns list of path grouping fields\n * that the model's spec contains.\n */\nexport function pathGroupingFields(mark: Mark, encoding: Encoding<string>): string[] {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'order':\n      case 'href':\n      case 'x2':\n      case 'y2':\n      case 'xError':\n      case 'yError':\n      case 'xError2':\n      case 'yError2':\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2':\n      // TODO: case 'cursor':\n\n      // text, shape, shouldn't be a part of line/trail/area\n      case 'text':\n      case 'shape':\n\n      // tooltip fields should not be added to group by\n      case 'tooltip':\n        return details;\n      case 'detail':\n      case 'key':\n        const channelDef = encoding[channel];\n        if (isArray(channelDef) || isFieldDef(channelDef)) {\n          (isArray(channelDef) ? channelDef : [channelDef]).forEach(fieldDef => {\n            if (!fieldDef.aggregate) {\n              details.push(vgField(fieldDef, {}));\n            }\n          });\n        }\n        return details;\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n      // For line, it should group lines.\n\n      /* tslint:disable */\n      // intentional fall through\n\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n      case 'fillOpacity':\n      case 'strokeOpacity':\n      case 'strokeWidth':\n        // TODO strokeDashOffset:\n\n        /* tslint:enable */\n        const fieldDef = getTypedFieldDef<string>(encoding[channel]);\n        if (fieldDef && !fieldDef.aggregate) {\n          details.push(vgField(fieldDef, {}));\n        }\n        return details;\n      default:\n        throw new Error(`Bug: Channel ${channel} unimplemented for line mark`);\n    }\n  }, []);\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the domainRaw property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return (xScale && xScale.get('domainRaw')) || (yScale && yScale.get('domainRaw')) ? true : false;\n}\n"]}