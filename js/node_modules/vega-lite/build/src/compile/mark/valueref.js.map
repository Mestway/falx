{"version":3,"file":"valueref.js","sourceRoot":"","sources":["../../../../src/compile/mark/valueref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utility files for producing Vega ValueRef for marks\n */\nimport {SignalRef} from 'vega';\nimport {isArray, isFunction, isString, stringValue} from 'vega-util';\nimport {isBinned, isBinning} from '../../bin';\nimport {Channel, getMainRangeChannel, X, X2, Y, Y2} from '../../channel';\nimport {Config} from '../../config';\nimport {Encoding, forEach} from '../../encoding';\nimport {\n  binRequiresRange,\n  ChannelDef,\n  ChannelDefWithCondition,\n  FieldDef,\n  FieldDefBase,\n  FieldRefOption,\n  format,\n  hasConditionalFieldDef,\n  isFieldDef,\n  isTypedFieldDef,\n  isValueDef,\n  SecondaryFieldDef,\n  title,\n  TypedFieldDef,\n  vgField\n} from '../../fielddef';\nimport * as log from '../../log';\nimport {Mark, MarkDef} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {QUANTITATIVE} from '../../type';\nimport {contains, some} from '../../util';\nimport {VgValueRef} from '../../vega.schema';\nimport {formatSignalRef} from '../common';\nimport {ScaleComponent} from '../scale/component';\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function position(\n  channel: 'x' | 'y',\n  channelDef: ChannelDef,\n  channel2Def: ChannelDef,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return fieldRef(channelDef, scaleName, {suffix: 'end'});\n  }\n  return midPoint(channel, channelDef, channel2Def, scaleName, scale, stack, defaultRef);\n}\n\n/**\n * @return Vega ValueRef for normal x2- or y2-position without projection\n */\nexport function position2(\n  channel: 'x2' | 'y2',\n  aFieldDef: ChannelDef,\n  a2fieldDef: ChannelDef,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  if (\n    isFieldDef(aFieldDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return fieldRef(aFieldDef, scaleName, {suffix: 'start'});\n  }\n  return midPoint(channel, a2fieldDef, undefined, scaleName, scale, stack, defaultRef);\n}\n\nexport function getOffset(channel: 'x' | 'y' | 'x2' | 'y2', markDef: MarkDef) {\n  const offsetChannel = channel + 'Offset';\n  // TODO: in the future read from encoding channel too\n\n  const markDefOffsetValue = markDef[offsetChannel];\n  if (markDefOffsetValue) {\n    return markDefOffsetValue;\n  }\n\n  return undefined;\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function bin(fieldDef: TypedFieldDef<string>, scaleName: string, side: 'start' | 'end', offset?: number) {\n  const binSuffix = side === 'start' ? undefined : 'end';\n  return fieldRef(fieldDef, scaleName, {binSuffix}, offset ? {offset} : {});\n}\n\nexport function fieldRef(\n  fieldDef: FieldDefBase<string>,\n  scaleName: string,\n  opt: FieldRefOption,\n  mixins?: {offset?: number | VgValueRef; band?: number | boolean}\n): VgValueRef {\n  const ref: VgValueRef = {\n    ...(scaleName ? {scale: scaleName} : {}),\n    field: vgField(fieldDef, opt)\n  };\n\n  if (mixins) {\n    return {\n      ...ref,\n      ...mixins\n    };\n  }\n  return ref;\n}\n\nexport function bandRef(scaleName: string, band: number | boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nfunction binMidSignal(scaleName: string, fieldDef: TypedFieldDef<string>, fieldDef2?: SecondaryFieldDef<string>) {\n  const start = vgField(fieldDef, {expr: 'datum'});\n  const end =\n    fieldDef2 !== undefined\n      ? vgField(fieldDef2, {expr: 'datum'})\n      : vgField(fieldDef, {binSuffix: 'end', expr: 'datum'});\n\n  return {\n    signal: `scale(\"${scaleName}\", (${start} + ${end}) / 2)`\n  };\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(\n  channel: Channel,\n  channelDef: ChannelDef,\n  channel2Def: ChannelDef<SecondaryFieldDef<string>>,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  // TODO: datum support\n\n  if (channelDef) {\n    /* istanbul ignore else */\n\n    if (isFieldDef(channelDef)) {\n      if (isTypedFieldDef(channelDef)) {\n        if (isBinning(channelDef.bin)) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (contains([X, Y], channel) && channelDef.type === QUANTITATIVE) {\n            if (stack && stack.impute) {\n              // For stack, we computed bin_mid so we can impute.\n              return fieldRef(channelDef, scaleName, {binSuffix: 'mid'});\n            }\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return binMidSignal(scaleName, channelDef);\n          }\n          return fieldRef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {binSuffix: 'range'} : {});\n        } else if (isBinned(channelDef.bin)) {\n          if (isFieldDef(channel2Def)) {\n            return binMidSignal(scaleName, channelDef, channel2Def);\n          } else {\n            const channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      if (scale) {\n        const scaleType = scale.get('type');\n        if (hasDiscreteDomain(scaleType)) {\n          if (scaleType === 'band') {\n            // For band, to get mid point, need to offset by half of the band\n            return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, {band: 0.5});\n          }\n          return fieldRef(channelDef, scaleName, {binSuffix: 'range'});\n        }\n      }\n      return fieldRef(channelDef, scaleName, {}); // no need for bin suffix\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n\n      if (contains(['x', 'x2'], channel) && value === 'width') {\n        return {field: {group: 'width'}};\n      } else if (contains(['y', 'y2'], channel) && value === 'height') {\n        return {field: {group: 'height'}};\n      }\n\n      return {value};\n    }\n\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  return isFunction(defaultRef) ? defaultRef() : defaultRef;\n}\n\nexport function tooltipForEncoding(encoding: Encoding<string>, config: Config) {\n  const keyValues: string[] = [];\n  const usedKey = {};\n\n  function add(fieldDef: TypedFieldDef<string> | SecondaryFieldDef<string>, channel: Channel) {\n    const mainChannel = getMainRangeChannel(channel);\n    if (channel !== mainChannel) {\n      fieldDef = {\n        ...fieldDef,\n        type: encoding[mainChannel].type\n      };\n    }\n\n    const key = title(fieldDef, config, {allowDisabling: false});\n    const value = text(fieldDef, config).signal;\n\n    if (!usedKey[key]) {\n      keyValues.push(`${stringValue(key)}: ${value}`);\n    }\n    usedKey[key] = true;\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n  return keyValues.length ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n\nexport function text(\n  channelDef: ChannelDefWithCondition<FieldDef<string>, string | number | boolean>,\n  config: Config\n): VgValueRef {\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return {value: channelDef.value};\n    }\n    if (isTypedFieldDef(channelDef)) {\n      return formatSignalRef(channelDef, format(channelDef), 'datum', config);\n    }\n  }\n  return undefined;\n}\n\nexport function mid(sizeRef: SignalRef): VgValueRef {\n  return {...sizeRef, mult: 0.5};\n}\n\n/**\n * Whether the scale definitely includes zero in the domain\n */\nfunction domainDefinitelyIncludeZero(scale: ScaleComponent) {\n  if (scale.get('zero') !== false) {\n    return true;\n  }\n  const domains = scale.domains;\n  if (isArray(domains)) {\n    return some(domains, d => isArray(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);\n  }\n  return false;\n}\n\nexport function getDefaultRef(\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax',\n  channel: 'x' | 'y',\n  scaleName: string,\n  scale: ScaleComponent,\n  mark: Mark\n) {\n  return () => {\n    if (isString(defaultRef)) {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (mark === 'bar' || mark === 'area') {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, channel, {scaleType}));\n          }\n        } else {\n          if (domainDefinitelyIncludeZero(scale)) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n          if (mark === 'bar' || mark === 'area') {\n            log.warn(\n              log.message.nonZeroScaleUsedWithLengthMark(mark, channel, {zeroFalse: scale.explicit.zero === false})\n            );\n          }\n        }\n      }\n\n      if (defaultRef === 'zeroOrMin') {\n        return channel === 'x' ? {value: 0} : {field: {group: 'height'}};\n      } else {\n        // zeroOrMax\n        return channel === 'x' ? {field: {group: 'width'}} : {value: 0};\n      }\n    }\n    return defaultRef;\n  };\n}\n"]}