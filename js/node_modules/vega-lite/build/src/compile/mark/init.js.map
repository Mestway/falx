{"version":3,"file":"init.js","sourceRoot":"","sources":["../../../../src/compile/mark/init.ts"],"names":[],"mappings":"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","sourcesContent":["import {isBinned, isBinning} from '../../bin';\nimport {Config} from '../../config';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {isContinuous, isFieldDef, TypedFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {AREA, BAR, CIRCLE, isMarkDef, LINE, Mark, MarkDef, POINT, RECT, RULE, SQUARE, TEXT, TICK} from '../../mark';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, getFirstDefined} from '../../util';\nimport {Orient} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\n\nexport function normalizeMarkDef(mark: Mark | MarkDef, encoding: Encoding<string>, config: Config) {\n  const markDef: MarkDef = isMarkDef(mark) ? {...mark} : {type: mark};\n\n  // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n  const specifiedOrient = markDef.orient || getMarkConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n\n  // set opacity and filled if not specified in mark config\n  const specifiedOpacity = getFirstDefined(markDef.opacity, getMarkConfig('opacity', markDef, config));\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n\n  const specifiedFilled = markDef.filled;\n  if (specifiedFilled === undefined) {\n    markDef.filled = filled(markDef, config);\n  }\n\n  // set cursor, which should be pointer if href channel is present unless otherwise specified\n  const specifiedCursor = markDef.cursor || getMarkConfig('cursor', markDef, config);\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef: MarkDef, encoding: Encoding<string>, config: Config) {\n  if (encoding.href || markDef.href || getMarkConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n  return markDef.cursor;\n}\n\nfunction opacity(mark: Mark, encoding: Encoding<string>) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\n\nfunction filled(markDef: MarkDef, config: Config) {\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\n\nfunction orient(mark: Mark, encoding: Encoding<string>, specifiedOrient: Orient): Orient {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const {x, y, x2, y2} = encoding;\n\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && isBinned(x.bin)) {\n        return 'vertical';\n      }\n      if (isFieldDef(y) && isBinned(y.bin)) {\n        return 'horizontal';\n      }\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        }\n\n        // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n        if (!x2 && isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin)) {\n          return 'horizontal';\n        }\n\n        // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n        if (!y2 && isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin)) {\n          return 'vertical';\n        }\n      }\n    /* tslint:disable */\n    case RULE: // intentionally fall through\n      // return undefined for line segment rule and bar with both axis ranged\n      if (x2 && y2) {\n        return undefined;\n      }\n\n    case AREA: // intentionally fall through\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (encoding.x && !encoding.y) {\n          return 'vertical';\n        } else if (encoding.y && !encoding.x) {\n          return 'horizontal';\n        }\n      }\n\n    case LINE: // intentional fall through\n    case TICK: // Tick is opposite to bar, line, area and never have ranged mark.\n      /* tslint:enable */\n      const xIsContinuous = isFieldDef(encoding.x) && isContinuous(encoding.x);\n      const yIsContinuous = isFieldDef(encoding.y) && isContinuous(encoding.y);\n      if (xIsContinuous && !yIsContinuous) {\n        return mark !== 'tick' ? 'horizontal' : 'vertical';\n      } else if (!xIsContinuous && yIsContinuous) {\n        return mark !== 'tick' ? 'vertical' : 'horizontal';\n      } else if (xIsContinuous && yIsContinuous) {\n        const xDef = encoding.x as TypedFieldDef<string>; // we can cast here since they are surely fieldDef\n        const yDef = encoding.y as TypedFieldDef<string>;\n\n        const xIsTemporal = xDef.type === TEMPORAL;\n        const yIsTemporal = yDef.type === TEMPORAL;\n\n        // temporal without timeUnit is considered continuous, but better serves as dimension\n        if (xIsTemporal && !yIsTemporal) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (!xIsTemporal && yIsTemporal) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (!xDef.aggregate && yDef.aggregate) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xDef.aggregate && !yDef.aggregate) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        return 'vertical';\n      } else {\n        // Discrete x Discrete case\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        return undefined;\n      }\n  }\n  return 'vertical';\n}\n"]}