{"version":3,"file":"signal.js","sourceRoot":"","sources":["../../../src/compile/signal.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,OAAO,EAAE,KAAK,EAAC,MAAM,iBAAiB,CAAC;AAC/C,OAAO,EAAC,WAAW,EAAC,MAAM,WAAW,CAAC;AACtC,OAAO,EAAC,qBAAqB,EAAE,IAAI,EAAC,MAAM,SAAS,CAAC;AAEpD;;GAEG;AACH,MAAM,OAAO,kBAAkB;IAC7B,YAAmB,IAAY,EAAS,WAAqB;QAA1C,SAAI,GAAJ,IAAI,CAAQ;QAAS,gBAAW,GAAX,WAAW,CAAU;IAAG,CAAC;IAE1D,MAAM,CAAC,QAAQ,CAAC,UAAkB;QACvC,OAAO,IAAI,kBAAkB,CAAC,UAAU,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;IAC1D,CAAC;IAED;;OAEG;IACI,GAAG,CAAC,CAA2B;QACpC,OAAO,IAAI,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;IAChE,CAAC;CACF;AAED,MAAM,QAAQ,GAAG,OAAO,CAAC,EAAC,SAAS,EAAE,QAAQ,EAAC,CAAC,CAAC;AAEhD,MAAM,UAAU,4BAA4B,CAC1C,IAAY,EACZ,MAAoF;IAEpF,MAAM,QAAQ,GAAa,IAAI,CAAC,MAAM,CAAC,CAAC;IACxC,MAAM,WAAW,GAAG,EAAE,CAAC;IAEvB,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;QAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;QAC9B,IAAI,KAAK,YAAY,kBAAkB,EAAE;YACvC,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC,WAAW,EAAE;gBACpC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACxB;YACD,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;SACjE;aAAM;YACL,kBAAkB;YAClB,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,qBAAqB,CAAC,OAAO,CAAC,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;SACzE;KACF;IAED,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;QAC1B,OAAO,IAAI,kBAAkB,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;KAClD;SAAM;QACL,IAAI;YACF,qEAAqE;YAErE,MAAM,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;YACxB,MAAM,EAAC,IAAI,EAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;YAC7B,MAAM,CAAC,GAAG,IAAI,QAAQ,CAAC,QAAQ,EAAE,UAAU,IAAI,GAAG,CAAC,CAAC,CAAC,2CAA2C;YAChG,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC;SAClB;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,uBAAuB,CAAC,KAAK,CAAC,EAAE;gBACxD,uHAAuH;gBACvH,OAAO,IAAI,kBAAkB,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;aACzC;YACD,MAAM,KAAK,CAAC;SACb;KACF;AACH,CAAC","sourcesContent":["import {codegen, parse} from 'vega-expression';\nimport {stringValue} from 'vega-util';\nimport {globalWholeWordRegExp, keys} from '../util';\n\n/**\n * A class that wraps an expression with a list signal names in the expression. If they are renamed during parsing multi-views,   we can rename then signals in the assemble phase.\n */\nexport class SignalRefComponent {\n  constructor(public expr: string, public signalNames: string[]) {}\n\n  public static fromName(signalName: string) {\n    return new SignalRefComponent(signalName, [signalName]);\n  }\n\n  /**\n   * Generate new signal based on this signal\n   */\n  public map(f: (expr: string) => string) {\n    return new SignalRefComponent(f(this.expr), this.signalNames);\n  }\n}\n\nconst generate = codegen({globalvar: 'global'});\n\nexport function evalOrMakeSignalRefComponent(\n  expr: string,\n  params: {[varname: string]: number | string | boolean | object | SignalRefComponent}\n) {\n  const varNames: string[] = keys(params);\n  const signalNames = [];\n\n  for (const varName of varNames) {\n    const param = params[varName];\n    if (param instanceof SignalRefComponent) {\n      for (const name of param.signalNames) {\n        signalNames.push(name);\n      }\n      expr = expr.replace(globalWholeWordRegExp(varName), param.expr);\n    } else {\n      // primitive value\n      expr = expr.replace(globalWholeWordRegExp(varName), stringValue(param));\n    }\n  }\n\n  if (signalNames.length > 0) {\n    return new SignalRefComponent(expr, signalNames);\n  } else {\n    try {\n      // Try to evaluate the expression and return the value if we succeed.\n\n      const ast = parse(expr);\n      const {code} = generate(ast);\n      const f = new Function('global', `return ${code};`); // tslint:disable-line:function-constructor\n      return f(params);\n    } catch (error) {\n      if (error.message.indexOf('Unrecognized function') === 0) {\n        // This expression contains a function that needs to be evaluated at runtime, so let's keep it as a SignalRefComponent.\n        return new SignalRefComponent(expr, []);\n      }\n      throw error;\n    }\n  }\n}\n"]}