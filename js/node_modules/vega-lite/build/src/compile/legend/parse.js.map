{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/legend/parse.ts"],"names":[],"mappings":"AACA,OAAO,EACL,KAAK,EACL,IAAI,EACJ,WAAW,EAEX,OAAO,EACP,KAAK,EACL,IAAI,EACJ,MAAM,EACN,aAAa,EACb,WAAW,EACZ,MAAM,eAAe,CAAC;AACvB,OAAO,EAAC,gBAAgB,EAAE,UAAU,EAAE,KAAK,IAAI,aAAa,EAAgB,MAAM,gBAAgB,CAAC;AACnG,OAAO,EAAS,iBAAiB,EAAE,oBAAoB,EAAC,MAAM,cAAc,CAAC;AAC7E,OAAO,EAAC,OAAO,EAAC,MAAM,YAAY,CAAC;AACnC,OAAO,EAAC,oBAAoB,EAAE,eAAe,EAAE,IAAI,EAAC,MAAM,YAAY,CAAC;AACvE,OAAO,EAAC,mBAAmB,EAAE,YAAY,EAAC,MAAM,WAAW,CAAC;AAC5D,OAAO,EAAC,gBAAgB,EAAC,MAAM,UAAU,CAAC;AAC1C,OAAO,EAAC,WAAW,EAAQ,MAAM,UAAU,CAAC;AAC5C,OAAO,EAAC,iBAAiB,EAAC,MAAM,YAAY,CAAC;AAC7C,OAAO,EAAC,iBAAiB,EAAY,YAAY,EAAE,uBAAuB,EAAC,MAAM,UAAU,CAAC;AAE5F,OAAO,EAAC,eAAe,EAAuB,MAAM,aAAa,CAAC;AAClE,OAAO,KAAK,MAAM,MAAM,UAAU,CAAC;AACnC,OAAO,KAAK,UAAU,MAAM,cAAc,CAAC;AAC3C,OAAO,EAAC,SAAS,EAAE,IAAI,EAAC,MAAM,cAAc,CAAC;AAE7C,MAAM,UAAU,WAAW,CAAC,KAAY;IACtC,IAAI,WAAW,CAAC,KAAK,CAAC,EAAE;QACtB,KAAK,CAAC,SAAS,CAAC,OAAO,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC;KAClD;SAAM;QACL,KAAK,CAAC,SAAS,CAAC,OAAO,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;KACrD;AACH,CAAC;AAED,SAAS,eAAe,CAAC,KAAgB;IACvC,MAAM,EAAC,QAAQ,EAAC,GAAG,KAAK,CAAC;IACzB,OAAO,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC,MAAM,CAChG,CAAC,eAAe,EAAE,OAAO,EAAE,EAAE;QAC3B,MAAM,GAAG,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC9B,IACE,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC;YACrB,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC;YAChC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,KAAK,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC,EACjE;YACA,eAAe,CAAC,OAAO,CAAC,GAAG,qBAAqB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;SAClE;QACD,OAAO,eAAe,CAAC;IACzB,CAAC,EACD,EAAE,CACH,CAAC;AACJ,CAAC;AAED,SAAS,qBAAqB,CAAC,KAAgB,EAAE,OAAgC;IAC/E,2GAA2G;IAC3G,QAAQ,OAAO,EAAE;QACf,KAAK,KAAK;YACR,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACrC,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAC,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC,CAAC,EAAC,MAAM,EAAE,KAAK,EAAC,CAAC;QAChE,KAAK,IAAI,CAAC;QACV,KAAK,MAAM,CAAC;QACZ,KAAK,WAAW,CAAC;QACjB,KAAK,IAAI,CAAC;QACV,KAAK,KAAK,CAAC;QACX,KAAK,OAAO,CAAC;QACb,KAAK,WAAW,CAAC;QACjB,KAAK,aAAa;YAChB,OAAO,EAAC,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,EAAC,CAAC;KAChD;AACH,CAAC;AAED,SAAS,UAAU,CACjB,KAAQ,EACR,QAAwB,EACxB,MAAc,EACd,QAA+B;IAE/B,QAAQ,QAAQ,EAAE;QAChB,KAAK,QAAQ;YACX,yEAAyE;YACzE,OAAO,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC;QACzB,KAAK,OAAO;YACV,iDAAiD;YACjD,IAAI,QAAQ,KAAK,OAAO,IAAI,KAAK,KAAK,QAAQ,CAAC,KAAK,EAAE;gBACpD,OAAO,IAAI,CAAC;aACb;KACJ;IACD,sFAAsF;IACtF,OAAO,KAAK,KAAK,MAAM,CAAC,QAAQ,CAAC,CAAC;AACpC,CAAC;AAED,MAAM,UAAU,qBAAqB,CAAC,KAAgB,EAAE,OAAgC;IACtF,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IACzC,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAErC,MAAM,UAAU,GAAG,IAAI,eAAe,CAAC,EAAE,EAAE,qBAAqB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;IAElF,KAAK,MAAM,QAAQ,IAAI,iBAAiB,EAAE;QACxC,MAAM,KAAK,GAAG,WAAW,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QAC5D,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,MAAM,QAAQ,GAAG,UAAU,CAAC,KAAK,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;YAC/D,IAAI,QAAQ,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;gBAC3D,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;aAC3C;SACF;KACF;IAED,MAAM,cAAc,GAAG,MAAM,CAAC,QAAQ,IAAI,EAAE,CAAC;IAC7C,MAAM,YAAY,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC,MAAM,CAC9E,CAAC,CAAe,EAAE,IAAI,EAAE,EAAE;QACxB,MAAM,kBAAkB,GAAG,gBAAgB,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,KAAK,CAAC,CAAC;QAC/E,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC;YACxB,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,kBAAkB,EAAE,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC,aAAa;YACtF,CAAC,CAAC,kBAAkB,CAAC,CAAC,iCAAiC;QACzD,IAAI,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;YACjD,CAAC,CAAC,IAAI,CAAC,GAAG,EAAC,MAAM,EAAE,KAAK,EAAC,CAAC;SAC3B;QACD,OAAO,CAAC,CAAC;IACX,CAAC,EACD,EAAkB,CACnB,CAAC;IAEF,IAAI,IAAI,CAAC,YAAY,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;QACjC,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,YAAY,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;KAC3D;IAED,OAAO,UAAU,CAAC;AACpB,CAAC;AAED,SAAS,WAAW,CAClB,QAAW,EACX,MAAc,EACd,OAAgC,EAChC,KAAgB;IAEhB,MAAM,EAAC,QAAQ,EAAC,GAAG,KAAK,CAAC;IACzB,MAAM,QAAQ,GAAG,gBAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;IACrD,MAAM,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC;IACzC,MAAM,EAAC,QAAQ,EAAC,GAAG,QAAQ,CAAC;IAE5B,MAAM,SAAS,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAE/D,QAAQ,QAAQ,EAAE;QAChB,KAAK,QAAQ;YACX,0EAA0E;YAC1E,OAAO,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;QAC7D,KAAK,OAAO;YACV,OAAO,aAAa,CAAC,QAAQ,EAAE,KAAK,CAAC,MAAM,EAAE,EAAC,cAAc,EAAE,IAAI,EAAC,CAAC,IAAI,SAAS,CAAC;QAEpF,KAAK,MAAM;YACT,OAAO,IAAI,CAAC,EAAC,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,YAAY,EAAE,KAAK,EAAC,CAAC,CAAC;QAE3E,KAAK,WAAW;YACd,OAAO,SAAS,CAAC,EAAC,MAAM,EAAE,YAAY,EAAE,QAAQ,EAAE,OAAO,EAAE,SAAS,EAAC,CAAC,CAAC;QAEzE,sEAAsE;QACtE,qBAAqB;QACrB,qGAAqG;QACrG,KAAK,cAAc;YACjB,OAAO,eAAe,CAAC,MAAM,CAAC,YAAY,EAAE,UAAU,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC,CAAC;QACzF,KAAK,gBAAgB;YACnB,OAAO,eAAe;YACpB,oCAAoC;YACpC,MAAM,CAAC,cAAc,EACrB,YAAY,CAAC,cAAc;YAC3B,oDAAoD;YACpD,UAAU,CAAC,qBAAqB,CAAC;gBAC/B,KAAK;gBACL,MAAM;gBACN,YAAY;gBACZ,OAAO;gBACP,SAAS;aACV,CAAC,CACH,CAAC;QAEJ,KAAK,QAAQ;YACX,OAAO,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;KAC9C;IAED,wCAAwC;IACxC,OAAQ,MAAmB,CAAC,QAAQ,CAAC,CAAC;AACxC,CAAC;AAED,SAAS,kBAAkB,CAAC,KAAY;IACtC,MAAM,EAAC,OAAO,EAAE,OAAO,EAAC,GAAG,KAAK,CAAC,SAAS,CAAC;IAE3C,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,QAAQ,EAAE;QAClC,WAAW,CAAC,KAAK,CAAC,CAAC;QAEnB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,OAAgC,EAAE,EAAE;YACzE,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,iBAAiB,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YAE9E,IAAI,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,QAAQ,EAAE;gBACxC,2DAA2D;gBAC3D,sDAAsD;gBAEtD,OAAO,CAAC,OAAO,CAAC,GAAG,oBAAoB,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;gBAE5F,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;oBACrB,qFAAqF;oBACrF,oEAAoE;oBACpE,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,aAAa,CAAC;oBACxC,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC;iBACzB;aACF;QACH,CAAC,CAAC,CAAC;KACJ;IAED,IAAI,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,OAAgC,EAAE,EAAE;QACzD,KAAK,MAAM,KAAK,IAAI,KAAK,CAAC,QAAQ,EAAE;YAClC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;gBACrC,sDAAsD;gBACtD,SAAS;aACV;YAED,IAAI,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,QAAQ,EAAE;gBACxC,qEAAqE;gBACrE,OAAO,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;aACzC;SACF;IACH,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,YAA6B,EAAE,WAA4B;IAC9F,IAAI,CAAC,YAAY,EAAE;QACjB,OAAO,WAAW,CAAC,KAAK,EAAE,CAAC;KAC5B;IACD,MAAM,YAAY,GAAG,YAAY,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;IAC5D,MAAM,WAAW,GAAG,WAAW,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;IAE1D,IAAI,YAAY,CAAC,QAAQ,IAAI,WAAW,CAAC,QAAQ,IAAI,YAAY,CAAC,KAAK,KAAK,WAAW,CAAC,KAAK,EAAE;QAC7F,uGAAuG;QACvG,0CAA0C;QAC1C,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,UAAU,GAAG,KAAK,CAAC;IACvB,yBAAyB;IACzB,KAAK,MAAM,IAAI,IAAI,oBAAoB,EAAE;QACvC,MAAM,uBAAuB,GAAG,uBAAuB,CACrD,YAAY,CAAC,eAAe,CAAC,IAAI,CAAC,EAClC,WAAW,CAAC,eAAe,CAAC,IAAI,CAAC,EACjC,IAAI,EACJ,QAAQ;QAER,uBAAuB;QACvB,CAAC,EAAiB,EAAE,EAAiB,EAAO,EAAE;YAC5C,QAAQ,IAAI,EAAE;gBACZ,KAAK,OAAO;oBACV,OAAO,mBAAmB,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;gBACrC,KAAK,MAAM;oBACT,0FAA0F;oBAC1F,UAAU,GAAG,IAAI,CAAC;oBAClB,OAAO,YAAY,CAAC,QAAQ,CAAC,CAAC;aACjC;YACD,OAAO,iBAAiB,CAAgB,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QAClE,CAAC,CACF,CAAC;QACF,YAAY,CAAC,eAAe,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;KAC7D;IACD,IAAI,UAAU,EAAE;QACd,IAAI,CAAC,CAAC,YAAY,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE;YACzD,oBAAoB,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC,CAAC;SACrE;QACD,IAAI,CAAC,CAAC,YAAY,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE;YACzD,oBAAoB,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC,CAAC;SACrE;KACF;IAED,OAAO,YAAY,CAAC;AACtB,CAAC","sourcesContent":["import {Legend as VgLegend, LegendEncode, SignalRef} from 'vega';\nimport {\n  COLOR,\n  FILL,\n  FILLOPACITY,\n  NonPositionScaleChannel,\n  OPACITY,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEOPACITY,\n  STROKEWIDTH\n} from '../../channel';\nimport {getTypedFieldDef, isFieldDef, title as fieldDefTitle, TypedFieldDef} from '../../fielddef';\nimport {Legend, LEGEND_PROPERTIES, VG_LEGEND_PROPERTIES} from '../../legend';\nimport {GEOJSON} from '../../type';\nimport {deleteNestedProperty, getFirstDefined, keys} from '../../util';\nimport {mergeTitleComponent, numberFormat} from '../common';\nimport {guideEncodeEntry} from '../guide';\nimport {isUnitModel, Model} from '../model';\nimport {parseGuideResolve} from '../resolve';\nimport {defaultTieBreaker, Explicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {LegendComponent, LegendComponentIndex} from './component';\nimport * as encode from './encode';\nimport * as properties from './properties';\nimport {direction, type} from './properties';\n\nexport function parseLegend(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.legends = parseUnitLegend(model);\n  } else {\n    model.component.legends = parseNonUnitLegend(model);\n  }\n}\n\nfunction parseUnitLegend(model: UnitModel): LegendComponentIndex {\n  const {encoding} = model;\n  return [COLOR, FILL, STROKE, STROKEWIDTH, SIZE, SHAPE, OPACITY, FILLOPACITY, STROKEOPACITY].reduce(\n    (legendComponent, channel) => {\n      const def = encoding[channel];\n      if (\n        model.legend(channel) &&\n        model.getScaleComponent(channel) &&\n        !(isFieldDef(def) && (channel === SHAPE && def.type === GEOJSON))\n      ) {\n        legendComponent[channel] = parseLegendForChannel(model, channel);\n      }\n      return legendComponent;\n    },\n    {}\n  );\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: NonPositionScaleChannel): VgLegend {\n  // For binned field with continuous scale, use a special scale so we can override the mark props and labels\n  switch (channel) {\n    case COLOR:\n      const scale = model.scaleName(COLOR);\n      return model.markDef.filled ? {fill: scale} : {stroke: scale};\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      return {[channel]: model.scaleName(channel)};\n  }\n}\n\nfunction isExplicit<T extends string | number | object | boolean>(\n  value: T,\n  property: keyof VgLegend,\n  legend: Legend,\n  fieldDef: TypedFieldDef<string>\n) {\n  switch (property) {\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend.values;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef.title) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === legend[property];\n}\n\nexport function parseLegendForChannel(model: UnitModel, channel: NonPositionScaleChannel): LegendComponent {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n\n  for (const property of LEGEND_PROPERTIES) {\n    const value = getProperty(property, legend, channel, model);\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, fieldDef);\n      if (explicit || model.config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = legend.encoding || {};\n  const legendEncode = ['labels', 'legend', 'title', 'symbols', 'gradient'].reduce(\n    (e: LegendEncode, part) => {\n      const legendEncodingPart = guideEncodeEntry(legendEncoding[part] || {}, model);\n      const value = encode[part]\n        ? encode[part](fieldDef, legendEncodingPart, model, channel, legendCmpt) // apply rule\n        : legendEncodingPart; // no rule -- just default values\n      if (value !== undefined && keys(value).length > 0) {\n        e[part] = {update: value};\n      }\n      return e;\n    },\n    {} as LegendEncode\n  );\n\n  if (keys(legendEncode).length > 0) {\n    legendCmpt.set('encode', legendEncode, !!legend.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction getProperty<K extends keyof VgLegend>(\n  property: K,\n  legend: Legend,\n  channel: NonPositionScaleChannel,\n  model: UnitModel\n): VgLegend[K] {\n  const {encoding} = model;\n  const fieldDef = getTypedFieldDef(encoding[channel]);\n  const legendConfig = model.config.legend;\n  const {timeUnit} = fieldDef;\n\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  switch (property) {\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      return numberFormat(fieldDef, legend.format, model.config);\n    case 'title':\n      return fieldDefTitle(fieldDef, model.config, {allowDisabling: true}) || undefined;\n\n    case 'type':\n      return type({legend, channel, timeUnit, scaleType, alwaysReturn: false});\n\n    case 'direction':\n      return direction({legend, legendConfig, timeUnit, channel, scaleType});\n\n    // TODO: enable when https://github.com/vega/vega/issues/1351 is fixed\n    // case 'clipHeight':\n    //   return getFirstDefined(specifiedLegend.clipHeight, properties.clipHeight(properties.type(...)));\n    case 'labelOverlap':\n      return getFirstDefined(legend.labelOverlap, properties.defaultLabelOverlap(scaleType));\n    case 'gradientLength':\n      return getFirstDefined<number | SignalRef>(\n        // do specified gradientLength first\n        legend.gradientLength,\n        legendConfig.gradientLength,\n        // Otherwise, use smart default based on plot height\n        properties.defaultGradientLength({\n          model,\n          legend,\n          legendConfig,\n          channel,\n          scaleType\n        })\n      );\n\n    case 'values':\n      return properties.values(legend, fieldDef);\n  }\n\n  // Otherwise, return specified property.\n  return (legend as VgLegend)[property];\n}\n\nfunction parseNonUnitLegend(model: Model) {\n  const {legends, resolve} = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    });\n  }\n\n  keys(legends).forEach((channel: NonPositionScaleChannel) => {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  });\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend: LegendComponent, childLegend: LegendComponent): LegendComponent {\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false;\n  // Otherwise, let's merge\n  for (const prop of VG_LEGEND_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<VgLegend, any>(\n      mergedLegend.getWithExplicit(prop),\n      childLegend.getWithExplicit(prop),\n      prop,\n      'legend',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>): any => {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n        return defaultTieBreaker<VgLegend, any>(v1, v2, prop, 'legend');\n      }\n    );\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  if (typeMerged) {\n    if (((mergedLegend.implicit || {}).encode || {}).gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if (((mergedLegend.explicit || {}).encode || {}).gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n"]}