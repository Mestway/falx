{"version":3,"file":"unit.js","sourceRoot":"","sources":["../../../src/compile/unit.ts"],"names":[],"mappings":"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","sourcesContent":["import {NewSignal} from 'vega';\nimport {Axis} from '../axis';\nimport {\n  Channel,\n  GEOPOSITION_CHANNELS,\n  NONPOSITION_SCALE_CHANNELS,\n  SCALE_CHANNELS,\n  ScaleChannel,\n  SingleDefChannel,\n  X,\n  Y\n} from '../channel';\nimport {Config} from '../config';\nimport {Encoding, normalizeEncoding} from '../encoding';\nimport * as vlEncoding from '../encoding';\nimport {getTypedFieldDef, hasConditionalFieldDef, isFieldDef, TypedFieldDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {GEOSHAPE, isMarkDef, Mark, MarkDef} from '../mark';\nimport {Projection} from '../projection';\nimport {Domain, Scale} from '../scale';\nimport {SelectionDef} from '../selection';\nimport {LayoutSizeMixins, NormalizedUnitSpec} from '../spec';\nimport {stack, StackProperties} from '../stack';\nimport {Dict, duplicate} from '../util';\nimport {VgData, VgEncodeEntry, VgLayout} from '../vega.schema';\nimport {AxisIndex} from './axis/component';\nimport {parseUnitAxis} from './axis/parse';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {parseUnitLayoutSize} from './layoutsize/parse';\nimport {LegendIndex} from './legend/component';\nimport {normalizeMarkDef} from './mark/init';\nimport {parseMarkGroup} from './mark/mark';\nimport {isLayerModel, Model, ModelWithField} from './model';\nimport {RepeaterValue, replaceRepeaterInEncoding} from './repeater';\nimport {ScaleIndex} from './scale/component';\nimport {\n  assembleTopLevelSignals,\n  assembleUnitSelectionData,\n  assembleUnitSelectionMarks,\n  assembleUnitSelectionSignals,\n  parseUnitSelection\n} from './selection/selection';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  public readonly type: 'unit' = 'unit';\n  public readonly markDef: MarkDef;\n  public readonly encoding: Encoding<string>;\n\n  public readonly specifiedScales: ScaleIndex = {};\n\n  public readonly stack: StackProperties;\n\n  protected specifiedAxes: AxisIndex = {};\n\n  protected specifiedLegends: LegendIndex = {};\n\n  public specifiedProjection: Projection = {};\n\n  public readonly selection: Dict<SelectionDef> = {};\n  public children: Model[] = [];\n\n  constructor(\n    spec: NormalizedUnitSpec,\n    parent: Model,\n    parentGivenName: string,\n    parentGivenSize: LayoutSizeMixins = {},\n    repeater: RepeaterValue,\n    config: Config,\n    public fit: boolean\n  ) {\n    super(spec, parent, parentGivenName, config, repeater, undefined);\n    this.initSize({\n      ...parentGivenSize,\n      ...(spec.width ? {width: spec.width} : {}),\n      ...(spec.height ? {height: spec.height} : {})\n    });\n    const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n\n    const encoding = (this.encoding = normalizeEncoding(\n      replaceRepeaterInEncoding(spec.encoding || {}, repeater),\n      mark\n    ));\n\n    this.markDef = normalizeMarkDef(spec.mark, encoding, config);\n\n    // calculate stack properties\n    this.stack = stack(mark, encoding, this.config.stack);\n    this.specifiedScales = this.initScales(mark, encoding);\n\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegend(encoding);\n    this.specifiedProjection = spec.projection;\n\n    // Selections will be initialized upon parse.\n    this.selection = spec.selection;\n  }\n\n  public get hasProjection(): boolean {\n    const {encoding} = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n\n  /**\n   * Return specified Vega-lite scale domain for a particular channel\n   * @param channel\n   */\n  public scaleDomain(channel: ScaleChannel): Domain {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  public axis(channel: Channel): Axis {\n    return this.specifiedAxes[channel];\n  }\n\n  public legend(channel: Channel): Legend {\n    return this.specifiedLegends[channel];\n  }\n\n  private initScales(mark: Mark, encoding: Encoding<string>): ScaleIndex {\n    return SCALE_CHANNELS.reduce(\n      (scales, channel) => {\n        let fieldDef: TypedFieldDef<string>;\n        let specifiedScale: Scale;\n\n        const channelDef = encoding[channel];\n\n        if (isFieldDef(channelDef)) {\n          fieldDef = channelDef;\n          specifiedScale = channelDef.scale;\n        } else if (hasConditionalFieldDef(channelDef)) {\n          fieldDef = channelDef.condition;\n          specifiedScale = channelDef.condition['scale'];\n        }\n\n        if (fieldDef) {\n          scales[channel] = specifiedScale || {};\n        }\n        return scales;\n      },\n      {} as ScaleIndex\n    );\n  }\n\n  private initAxes(encoding: Encoding<string>): AxisIndex {\n    return [X, Y].reduce((_axis, channel) => {\n      // Position Axis\n\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n      if (\n        isFieldDef(channelDef) ||\n        (channel === X && isFieldDef(encoding.x2)) ||\n        (channel === Y && isFieldDef(encoding.y2))\n      ) {\n        const axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n        if (axisSpec !== null) {\n          _axis[channel] = {\n            ...axisSpec\n          };\n        }\n      }\n      return _axis;\n    }, {});\n  }\n\n  private initLegend(encoding: Encoding<string>): LegendIndex {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const channelDef = encoding[channel];\n      if (channelDef) {\n        const legend = isFieldDef(channelDef)\n          ? channelDef.legend\n          : hasConditionalFieldDef(channelDef)\n          ? channelDef.condition['legend']\n          : null;\n\n        if (legend !== null && legend !== false) {\n          _legend[channel] = {...legend};\n        }\n      }\n\n      return _legend;\n    }, {});\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n  }\n\n  public parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  public parseSelection() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  public parseMarkGroup() {\n    this.component.mark = parseMarkGroup(this);\n  }\n\n  public parseAxisAndHeader() {\n    this.component.axes = parseUnitAxis(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): NewSignal[] {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  public assembleSelectionSignals(): NewSignal[] {\n    return assembleUnitSelectionSignals(this, []);\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleLayoutSignals(): NewSignal[] {\n    return assembleLayoutSignals(this);\n  }\n\n  public assembleMarks() {\n    let marks = this.component.mark || [];\n\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n\n  public assembleLayoutSize(): VgEncodeEntry {\n    return {\n      width: this.getSizeSignalRef('width'),\n      height: this.getSizeSignalRef('height')\n    };\n  }\n\n  protected getMapping() {\n    return this.encoding;\n  }\n\n  public toSpec(excludeConfig?: any, excludeData?: any) {\n    const encoding = duplicate(this.encoding);\n    let spec: any;\n\n    spec = {\n      mark: this.markDef,\n      encoding: encoding\n    };\n\n    if (!excludeConfig) {\n      spec.config = duplicate(this.config);\n    }\n\n    if (!excludeData) {\n      spec.data = duplicate(this.data);\n    }\n\n    // remove defaults\n    return spec;\n  }\n\n  public get mark(): Mark {\n    return this.markDef.type;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  public fieldDef(channel: SingleDefChannel) {\n    const channelDef = this.encoding[channel];\n    return getTypedFieldDef<string>(channelDef);\n  }\n}\n"]}