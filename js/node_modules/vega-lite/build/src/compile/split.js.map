{"version":3,"file":"split.js","sourceRoot":"","sources":["../../../src/compile/split.ts"],"names":[],"mappings":"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","sourcesContent":["import * as log from '../log';\nimport {duplicate, getFirstDefined, keys, stringify} from '../util';\n\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\nexport class Split<T extends object> {\n  constructor(public readonly explicit: Partial<T> = {}, public readonly implicit: Partial<T> = {}) {}\n\n  public clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  public combine(): Partial<T> {\n    // FIXME remove \"as any\".\n    // Add \"as any\" to avoid an error \"Spread types may only be created from object types\".\n    return {\n      ...(this.explicit as any), // Explicit properties comes first\n      ...(this.implicit as any)\n    };\n  }\n\n  public get<K extends keyof T>(key: K): T[K] {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  public getWithExplicit<K extends keyof T>(key: K): Explicit<T[K]> {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {explicit: true, value: this.explicit[key]};\n    } else if (this.implicit[key] !== undefined) {\n      return {explicit: false, value: this.implicit[key]};\n    }\n    return {explicit: false, value: undefined};\n  }\n\n  public setWithExplicit<K extends keyof T>(key: K, value: Explicit<T[K]>) {\n    if (value.value !== undefined) {\n      this.set(key, value.value, value.explicit);\n    }\n  }\n\n  public set<K extends keyof T>(key: K, value: T[K], explicit: boolean) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  public copyKeyFromSplit<S extends T>(key: keyof T, s: Split<S>) {\n    // Explicit has higher precedence\n    if (s.explicit[key] !== undefined) {\n      this.set(key, s.explicit[key], true);\n    } else if (s.implicit[key] !== undefined) {\n      this.set(key, s.implicit[key], false);\n    }\n  }\n  public copyKeyFromObject<S extends Partial<T>>(key: keyof T, s: S) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  public copyAll(other: Split<T>) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\n\nexport interface Explicit<T> {\n  explicit: boolean;\n  value: T;\n}\n\nexport function makeExplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: true,\n    value\n  };\n}\n\nexport function makeImplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: false,\n    value\n  };\n}\n\nexport function tieBreakByComparing<S, T>(compare: (v1: T, v2: T) => number) {\n  return (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S | never,\n    propertyOf: string | number | symbol\n  ): Explicit<T> => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker<S, T>(v1, v2, property, propertyOf);\n  };\n}\n\nexport function defaultTieBreaker<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: string | number | symbol\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\n\nexport function mergeValuesWithExplicit<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: 'scale' | 'axis' | 'legend' | '',\n  tieBreaker: (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S,\n    propertyOf: string\n  ) => Explicit<T> = defaultTieBreaker\n) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (stringify(v1.value) === stringify(v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}\n"]}