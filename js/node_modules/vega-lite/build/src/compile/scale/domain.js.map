{"version":3,"file":"domain.js","sourceRoot":"","sources":["../../../../src/compile/scale/domain.ts"],"names":[],"mappings":"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","sourcesContent":["import {isString} from 'vega-util';\nimport {SHARED_DOMAIN_OP_INDEX} from '../../aggregate';\nimport {binToString, isBinning, isBinParams} from '../../bin';\nimport {isScaleChannel, ScaleChannel} from '../../channel';\nimport {MAIN, RAW} from '../../data';\nimport {DateTime} from '../../datetime';\nimport {binRequiresRange, ScaleFieldDef, TypedFieldDef, valueExpr, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {Domain, hasDiscreteDomain, isBinScale, isSelectionDomain, ScaleConfig, ScaleType} from '../../scale';\nimport {EncodingSortField, isSortArray, isSortField} from '../../sort';\nimport {TimeUnit} from '../../timeunit';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  VgDataRef,\n  VgDomain,\n  VgFieldRefUnionDomain,\n  VgNonUnionDomain,\n  VgSortField,\n  VgUnionSortField\n} from '../../vega.schema';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {FACET_SCALE_PREFIX} from '../data/optimize';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {SELECTION_DOMAIN} from '../selection/selection';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\n\nexport function parseScaleDomain(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model: UnitModel) {\n  const scales = model.specifiedScales;\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const specifiedScale = scales[channel];\n    const specifiedDomain = specifiedScale ? specifiedScale.domain : undefined;\n\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.domains = domains;\n\n    if (isSelectionDomain(specifiedDomain)) {\n      // As scale parsing occurs before selection parsing, we use a temporary\n      // signal here and append the scale.domain definition. This is replaced\n      // with the correct domainRaw signal during scale assembly.\n      // For more information, see isRawSelectionDomain in selection.ts.\n\n      // FIXME: replace this with a special property in the scaleComponent\n      localScaleCmpt.set(\n        'domainRaw',\n        {\n          signal: SELECTION_DOMAIN + util.hash(specifiedDomain)\n        },\n        true\n      );\n    }\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent: Model = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction parseNonUnitScaleDomain(model: Model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let domains: VgNonUnionDomain[];\n    let domainRaw = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.domains;\n        } else {\n          domains = domains.concat(childComponent.domains);\n        }\n\n        const dr = childComponent.get('domainRaw');\n        if (domainRaw && dr && domainRaw.signal !== dr.signal) {\n          log.warn('The same selection must be used to override scale domains in a layered view.');\n        }\n        domainRaw = dr;\n      }\n    }\n\n    localScaleComponents[channel].domains = domains;\n\n    if (domainRaw) {\n      localScaleComponents[channel].set('domainRaw', domainRaw, true);\n    }\n  });\n}\n\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(\n  domain: Domain,\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig\n) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model: UnitModel, channel: ScaleChannel): VgNonUnionDomain[] {\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  const domain = normalizeUnaggregatedDomain(\n    model.scaleDomain(channel),\n    model.fieldDef(channel),\n    scaleType,\n    model.config.scale\n  );\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x').concat(\n        parseSingleChannelDomain(scaleType, domain, model, 'x2')\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y').concat(\n        parseSingleChannelDomain(scaleType, domain, model, 'y2')\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal<T>(domain: T[], type: Type, timeUnit: TimeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {timeUnit, type});\n    return {signal: `{data: ${data}}`};\n  });\n}\n\nfunction parseSingleChannelDomain(\n  scaleType: ScaleType,\n  domain: Domain,\n  model: UnitModel,\n  channel: ScaleChannel | 'x2' | 'y2'\n): VgNonUnionDomain[] {\n  const fieldDef = model.fieldDef(channel);\n\n  if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n    // explicit value\n    const {type, timeUnit} = fieldDef;\n    if (type === 'temporal' || timeUnit) {\n      return mapDomainToDataSignal<number | string | boolean | DateTime>(domain, type, timeUnit);\n    }\n\n    return [domain];\n  }\n\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return [[0, 1]];\n    }\n\n    const data = model.requestDataName(MAIN);\n    return [\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'start'})\n      },\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'end'})\n      }\n    ];\n  }\n\n  const sort = isScaleChannel(channel) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(MAIN);\n    const {field} = fieldDef;\n    return [\n      {\n        data,\n        field: vgField({field, aggregate: 'min'})\n      },\n      {\n        data,\n        field: vgField({field, aggregate: 'max'})\n      }\n    ];\n  } else if (isBinning(fieldDef.bin)) {\n    // bin\n    if (isBinScale(scaleType)) {\n      const signal = model.getName(`${binToString(fieldDef.bin)}_${fieldDef.field}_bins`);\n      return [{signal: `sequence(${signal}.start, ${signal}.stop + ${signal}.step, ${signal}.step)`}];\n    }\n\n    if (hasDiscreteDomain(scaleType)) {\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return [\n        {\n          // If sort by aggregation of a specified sort field, we need to use RAW table,\n          // so we can aggregate values for the scale independently from the main aggregation.\n          data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n          // Use range if we added it and the scale does not support computing a range as a signal.\n          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {binSuffix: 'range'} : {}),\n          // we have to use a sort object if sort = true to make the sort correct by bin start\n          sort:\n            sort === true || !isSortField(sort)\n              ? {\n                  field: model.vgField(channel, {}),\n                  op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n                }\n              : sort\n        }\n      ];\n    } else {\n      // continuous scales\n      if (channel === 'x' || channel === 'y') {\n        if (isBinParams(fieldDef.bin) && fieldDef.bin.extent) {\n          return [fieldDef.bin.extent];\n        }\n        // X/Y position have to include start and end for non-ordinal scale\n        const data = model.requestDataName(MAIN);\n        return [\n          {\n            data,\n            field: model.vgField(channel, {})\n          },\n          {\n            data,\n            field: model.vgField(channel, {binSuffix: 'end'})\n          }\n        ];\n      } else {\n        // TODO: use bin_mid\n        return [\n          {\n            data: model.requestDataName(MAIN),\n            field: model.vgField(channel, {})\n          }\n        ];\n      }\n    }\n  } else if (sort) {\n    return [\n      {\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n        field: model.vgField(channel),\n        sort: sort\n      }\n    ];\n  } else {\n    return [\n      {\n        data: model.requestDataName(MAIN),\n        field: model.vgField(channel)\n      }\n    ];\n  }\n}\n\nexport function domainSort(\n  model: UnitModel,\n  channel: ScaleChannel,\n  scaleType: ScaleType\n): true | EncodingSortField<string> {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n  const fieldDef = model.fieldDef(channel) as ScaleFieldDef<string>;\n  const sort = fieldDef.sort;\n\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    // flatten nested fields\n    return {\n      ...sort,\n      ...(sort.field ? {field: util.replacePathInField(sort.field)} : {})\n    };\n  }\n\n  if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  }\n\n  if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort == null\n  return undefined;\n}\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType\n): {valid: boolean; reason?: string} {\n  if (!fieldDef.aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (!SHARED_DOMAIN_OP_INDEX[fieldDef.aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(fieldDef.aggregate)\n    };\n  }\n\n  if (fieldDef.type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains: VgNonUnionDomain[]): VgDomain {\n  const uniqueDomains = util.unique(\n    domains.map(domain => {\n      // ignore sort property when computing the unique domains\n      if (isDataRefDomain(domain)) {\n        const {sort: _s, ...domainWithoutSort} = domain;\n        return domainWithoutSort;\n      }\n      return domain;\n    }),\n    util.hash\n  );\n\n  const sorts: VgSortField[] = util.unique(\n    domains\n      .map(d => {\n        if (isDataRefDomain(d)) {\n          const s = d.sort;\n          if (s !== undefined && !util.isBoolean(s)) {\n            if (s.op === 'count') {\n              // let's make sure that if op is count, we don't use a field\n              delete s.field;\n            }\n            if (s.order === 'ascending') {\n              // drop order: ascending as it is the default\n              delete s.order;\n            }\n          }\n          return s;\n        }\n        return undefined;\n      })\n      .filter(s => s !== undefined),\n    util.hash\n  );\n\n  if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n\n  // only keep simple sort properties that work with unioned domains\n  const simpleSorts = util.unique(\n    sorts.map(s => {\n      if (util.isBoolean(s)) {\n        return s;\n      }\n      if (s.op === 'count') {\n        return s;\n      }\n      log.warn(log.message.domainSortDropped(s));\n      return true;\n    }),\n    util.hash\n  ) as VgUnionSortField[];\n\n  let sort: VgUnionSortField;\n\n  if (simpleSorts.length === 1) {\n    sort = simpleSorts[0];\n  } else if (simpleSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(\n    domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    }),\n    x => x\n  );\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain: VgFieldRefUnionDomain = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => (d as VgDataRef).field),\n      ...(sort ? {sort} : {})\n    };\n\n    return domain;\n  }\n\n  return {fields: uniqueDomains, ...(sort ? {sort} : {})};\n}\n\n/**\n * Return a field if a scale single field.\n * Return `undefined` otherwise.\n *\n */\nexport function getFieldFromDomain(domain: VgDomain): string {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(\n            'Detected faceted independent scales that union domain of multiple fields from different data sources.  We will use the first field.  The result view size may be incorrect.'\n          );\n          return field;\n        }\n      }\n    }\n    log.warn(\n      'Detected faceted independent scales that union domain of identical fields from different source detected.  We will assume that this is the same field from a different fork of the same data source.  However, if this is not case, the result view size maybe incorrect.'\n    );\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(\n      'Detected faceted independent scales that union domain of multiple fields from the same data source.  We will use the first field.  The result view size may be incorrect.'\n    );\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\n\nexport function assembleDomain(model: Model, channel: ScaleChannel) {\n  const scaleComponent = model.component.scales[channel];\n  const domains = scaleComponent.domains.map(domain => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n    return domain;\n  });\n\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}\n"]}