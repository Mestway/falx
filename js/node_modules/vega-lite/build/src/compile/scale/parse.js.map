{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/scale/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {SCALE_CHANNELS, ScaleChannel, SHAPE} from '../../channel';\nimport {hasConditionalFieldDef, isFieldDef, TypedFieldDef} from '../../fielddef';\nimport {GEOSHAPE} from '../../mark';\nimport {\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,\n  Scale,\n  scaleCompatible,\n  ScaleType,\n  scaleTypePrecedence\n} from '../../scale';\nimport {GEOJSON} from '../../type';\nimport {keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {defaultScaleResolve} from '../resolve';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\nimport {parseScaleDomain} from './domain';\nimport {parseScaleProperty, parseScaleRange} from './properties';\nimport {scaleType} from './type';\n\nexport function parseScale(model: Model) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  // range depends on zero\n  parseScaleRange(model);\n}\n\nexport function parseScaleCore(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model: UnitModel): ScaleComponentIndex {\n  const {encoding, config, mark} = model;\n\n  return SCALE_CHANNELS.reduce((scaleComponents: ScaleComponentIndex, channel: ScaleChannel) => {\n    let fieldDef: TypedFieldDef<string>;\n    let specifiedScale: Scale | null;\n\n    const channelDef = encoding[channel];\n\n    // Don't generate scale for shape of geoshape\n    if (isFieldDef(channelDef) && mark === GEOSHAPE && channel === SHAPE && channelDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef(channelDef)) {\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale || {};\n\n      const sType = scaleType(specifiedScale, channel, fieldDef, mark, config.scale);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + '', true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing(\n  (st1: ScaleType, st2: ScaleType) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2)\n);\n\nfunction parseNonUnitScaleCore(model: Model) {\n  const scaleComponents: ScaleComponentIndex = (model.component.scales = {});\n\n  const scaleTypeWithExplicitIndex: {\n    // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n    [k in ScaleChannel]?: Explicit<ScaleType>\n  } = {};\n  const resolve = model.component.resolve;\n\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    keys(child.component.scales).forEach((channel: ScaleChannel) => {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] = resolve.scale[channel] || defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit<VgScale, ScaleType>(\n              explicitScaleType,\n              childScaleType,\n              'type',\n              'scale',\n              scaleTypeTieBreaker\n            );\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    });\n  }\n\n  // Merge each channel listed in the index\n  keys(scaleTypeWithExplicitIndex).forEach((channel: ScaleChannel) => {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  });\n\n  return scaleComponents;\n}\n"]}