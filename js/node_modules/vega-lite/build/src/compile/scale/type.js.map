{"version":3,"file":"type.js","sourceRoot":"","sources":["../../../../src/compile/scale/type.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {Channel, isColorChannel, isScaleChannel, rangeType} from '../../channel';\nimport {TypedFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {channelSupportScaleType, Scale, ScaleConfig, ScaleType, scaleTypeSupportDataType} from '../../scale';\nimport * as util from '../../util';\n\nexport type RangeType = 'continuous' | 'discrete' | 'flexible' | undefined;\n\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(\n  specifiedScale: Scale,\n  channel: Channel,\n  fieldDef: TypedFieldDef<string>,\n  mark: Mark,\n  scaleConfig: ScaleConfig\n): ScaleType {\n  const defaultScaleType = defaultType(channel, fieldDef, mark, specifiedScale, scaleConfig);\n  const {type} = specifiedScale;\n\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    // Check if explicitly specified scale type is supported by the data type\n    if (!scaleTypeSupportDataType(type, fieldDef.type, fieldDef.bin)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return type;\n  }\n\n  return defaultScaleType;\n}\n\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(\n  channel: Channel,\n  fieldDef: TypedFieldDef<string>,\n  mark: Mark,\n  specifiedScale: Scale,\n  scaleConfig: ScaleConfig\n): ScaleType {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n        if (channel === 'shape' && fieldDef.type === 'ordinal') {\n          log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        }\n        return 'ordinal';\n      }\n\n      if (util.contains(['x', 'y'], channel)) {\n        if (util.contains(['rect', 'bar', 'rule'], mark)) {\n          // The rect/bar mark should fit into a band.\n          // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n          return 'band';\n        }\n        if (mark === 'bar') {\n          return 'band';\n        }\n      }\n      // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n      return 'point';\n\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'time';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n      return 'time';\n\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n\n        const {domain = undefined, range = undefined} = specifiedScale || {};\n        if (domain && isArray(domain) && domain.length > 2 && (range && isArray(range) && range.length > 2)) {\n          // If there are piecewise domain and range specified, use linear as default color scale as sequential does not support piecewise domain\n          return 'linear';\n        }\n\n        // Use `sequential` as the default color scale for continuous data\n        // since it supports both array range and scheme range.\n        return 'sequential';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n\n      // x and y use a linear scale because selections don't work with bin scales.\n      // Binned scales apply discretization but pan/zoom apply transformations to a [min, max] extent domain.\n      if (isBinning(fieldDef.bin) && channel !== 'x' && channel !== 'y') {\n        return 'bin-linear';\n      }\n      return 'linear';\n\n    case 'geojson':\n      return undefined;\n  }\n\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n"]}