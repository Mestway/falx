{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/compile/common.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {Config, StyleConfigIndex, ViewConfig} from '../config';\nimport {\n  FieldDefBase,\n  FieldRefOption,\n  isScaleFieldDef,\n  isTimeFieldDef,\n  OrderFieldDef,\n  TypedFieldDef,\n  vgField\n} from '../fielddef';\nimport {MarkConfig, MarkDef, TextConfig} from '../mark';\nimport {ScaleType} from '../scale';\nimport {formatExpression, TimeUnit} from '../timeunit';\nimport {QUANTITATIVE} from '../type';\nimport {getFirstDefined, stringify} from '../util';\nimport {VgCompare, VgEncodeEntry, VgMarkConfig} from '../vega.schema';\nimport {AxisComponentProps} from './axis/component';\nimport {Explicit} from './split';\nimport {UnitModel} from './unit';\n\nexport function applyConfig(\n  e: VgEncodeEntry,\n  config: ViewConfig | MarkConfig | TextConfig, // TODO(#1842): consolidate MarkConfig | TextConfig?\n  propsList: string[]\n) {\n  for (const property of propsList) {\n    const value = config[property];\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig)[]) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function getStyles(mark: MarkDef): string[] {\n  return [].concat(mark.type, mark.style || []);\n}\n\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkConfig>(\n  prop: P,\n  mark: MarkDef,\n  config: Config,\n  {skipGeneralMarkConfig = false}: {skipGeneralMarkConfig?: boolean} = {}\n): MarkConfig[P] {\n  return getFirstDefined(\n    // style config has highest precedence\n    getStyleConfig(prop, mark, config.style),\n    // then mark-specific config\n    config[mark.type][prop],\n    // then general mark config (if not skipped)\n    skipGeneralMarkConfig ? undefined : config.mark[prop]\n  );\n}\n\nexport function getStyleConfig<P extends keyof MarkConfig>(prop: P, mark: MarkDef, styleConfigIndex: StyleConfigIndex) {\n  const styles = getStyles(mark);\n  let value;\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n    // However here we also check if it is defined, so it is okay to cast here\n    const p = prop as keyof VgMarkConfig;\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n  return value;\n}\n\nexport function formatSignalRef(\n  fieldDef: TypedFieldDef<string>,\n  specifiedFormat: string,\n  expr: 'datum' | 'parent',\n  config: Config\n) {\n  const format = numberFormat(fieldDef, specifiedFormat, config);\n  if (isBinning(fieldDef.bin)) {\n    const startField = vgField(fieldDef, {expr});\n    const endField = vgField(fieldDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(startField, endField, format, config)\n    };\n  } else if (fieldDef.type === 'quantitative') {\n    return {\n      signal: `${formatExpr(vgField(fieldDef, {expr, binSuffix: 'range'}), format)}`\n    };\n  } else if (isTimeFieldDef(fieldDef)) {\n    const isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(\n        vgField(fieldDef, {expr}),\n        fieldDef.timeUnit,\n        specifiedFormat,\n        config.text.shortTimeLabels,\n        config.timeFormat,\n        isUTCScale,\n        true\n      )\n    };\n  } else {\n    return {\n      signal: `''+${vgField(fieldDef, {expr})}`\n    };\n  }\n}\n\n/**\n * Returns number format for a fieldDef\n */\nexport function numberFormat(fieldDef: TypedFieldDef<string>, specifiedFormat: string, config: Config) {\n  if (isTimeFieldDef(fieldDef)) {\n    return undefined;\n  }\n\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nexport function numberFormatExpr(field: string, specifiedFormat: string, config: Config) {\n  return formatExpr(field, specifiedFormat || config.numberFormat);\n}\n\nexport function binFormatExpression(startField: string, endField: string, format: string, config: Config) {\n  return `${startField} === null || isNaN(${startField}) ? \"null\" : ${numberFormatExpr(\n    startField,\n    format,\n    config\n  )} + \" - \" + ${numberFormatExpr(endField, format, config)}`;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(\n  field: string,\n  timeUnit: TimeUnit,\n  format: string,\n  shortTimeLabels: boolean,\n  rawTimeFormat: string, // should be provided only for actual text and headers, not axis/legend labels\n  isUTCScale: boolean,\n  alwaysReturn: boolean = false\n): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format || rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    if (format || alwaysReturn) {\n      return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, shortTimeLabels, isUTCScale);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(\n  orderDef: OrderFieldDef<string> | OrderFieldDef<string>[],\n  fieldRefOption?: FieldRefOption\n): VgCompare {\n  return (isArray(orderDef) ? orderDef : [orderDef]).reduce(\n    (s, orderChannelDef) => {\n      s.field.push(vgField(orderChannelDef, fieldRefOption));\n      s.order.push(orderChannelDef.sort || 'ascending');\n      return s;\n    },\n    {field: [], order: []}\n  );\n}\n\nexport type AxisTitleComponent = AxisComponentProps['title'];\n\nexport function mergeTitleFieldDefs(f1: FieldDefBase<string>[], f2: FieldDefBase<string>[]) {\n  const merged = [...f1];\n\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (stringify(fieldDef1) === stringify(fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\n\nexport function mergeTitle(title1: string, title2: string) {\n  if (title1 === title2 || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    // join title with comma if they are different\n    return title1 + ', ' + title2;\n  }\n}\n\nexport function mergeTitleComponent(v1: Explicit<AxisTitleComponent>, v2: Explicit<AxisTitleComponent>) {\n  if (isArray(v1.value) && isArray(v2.value)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1.value, v2.value)\n    };\n  } else if (!isArray(v1.value) && !isArray(v2.value)) {\n    return {\n      explicit: v1.explicit, // keep the old explicit\n      value: mergeTitle(v1.value, v2.value)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}\n"]}