{"version":3,"file":"stack.js","sourceRoot":"","sources":["../../src/stack.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,OAAO,EAAC,MAAM,WAAW,CAAC;AAClC,OAAO,EAAC,OAAO,EAAC,MAAM,aAAa,CAAC;AACpC,OAAO,EAAC,oBAAoB,EAAsB,CAAC,EAAE,EAAE,EAAE,EAAE,EAAC,MAAM,WAAW,CAAC;AAC9E,OAAO,EAAC,eAAe,EAAW,MAAM,YAAY,CAAC;AACrD,OAAO,EAEL,gBAAgB,EAChB,UAAU,EACV,gBAAgB,EAGhB,OAAO,EACR,MAAM,YAAY,CAAC;AACpB,OAAO,KAAK,GAAG,MAAM,OAAO,CAAC;AAC7B,OAAO,EAAC,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAiB,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAC,MAAM,QAAQ,CAAC;AACtH,OAAO,EAAC,SAAS,EAAC,MAAM,SAAS,CAAC;AAClC,OAAO,EAAC,QAAQ,EAAQ,eAAe,EAAC,MAAM,QAAQ,CAAC;AAIvD,MAAM,kBAAkB,GAAsB;IAC5C,IAAI,EAAE,CAAC;IACP,MAAM,EAAE,CAAC;IACT,SAAS,EAAE,CAAC;CACb,CAAC;AAEF,MAAM,UAAU,aAAa,CAAC,CAAS;IACrC,OAAO,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC;AACjC,CAAC;AA0BD,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAC1F,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAElD,SAAS,uBAAuB,CAAC,QAAyB;IACxD,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC;IACxB,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC;IAExB,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;QACxC,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE;YAChE,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,OAAO,GAAG,CAAC;aACZ;iBAAM,IAAI,IAAI,CAAC,KAAK,EAAE;gBACrB,OAAO,GAAG,CAAC;aACZ;YACD,+FAA+F;YAC/F,IAAI,CAAC,CAAC,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE;gBACzC,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;aACnC;SACF;aAAM,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE;YACvC,OAAO,GAAG,CAAC;SACZ;aAAM,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE;YACvC,OAAO,GAAG,CAAC;SACZ;KACF;SAAM,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE;QAC3D,OAAO,GAAG,CAAC;KACZ;SAAM,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE;QAC3D,OAAO,GAAG,CAAC;KACZ;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAED,iGAAiG;AACjG,gEAAgE;AAChE,MAAM,UAAU,KAAK,CAAC,CAAiB,EAAE,QAAyB,EAAE,WAAwB;IAC1F,MAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACvC,6BAA6B;IAC7B,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,IAAI,CAAC,EAAE;QACpC,OAAO,IAAI,CAAC;KACb;IAED,MAAM,YAAY,GAAG,uBAAuB,CAAC,QAAQ,CAAC,CAAC;IACvD,IAAI,CAAC,YAAY,EAAE;QACjB,OAAO,IAAI,CAAC;KACb;IAED,MAAM,eAAe,GAAG,QAAQ,CAAC,YAAY,CAA6B,CAAC;IAC3E,MAAM,YAAY,GAAG,gBAAgB,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAElG,MAAM,gBAAgB,GAAG,YAAY,KAAK,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IAC1D,MAAM,YAAY,GAAG,QAAQ,CAAC,gBAAgB,CAAC,CAAC;IAChD,MAAM,cAAc,GAAG,gBAAgB,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAE9F,kFAAkF;IAClF,MAAM,OAAO,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,EAAE,EAAE;QAC1D,IAAI,eAAe,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAE;YACtC,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;YACrC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC/D,MAAM,QAAQ,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;gBACxC,IAAI,QAAQ,CAAC,SAAS,EAAE;oBACtB,OAAO;iBACR;gBAED,8FAA8F;gBAC9F,MAAM,CAAC,GAAG,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBACzE;gBACE,2DAA2D;gBAC3D,CAAC,CAAC;oBACF,8DAA8D;oBAC9D,CAAC,CAAC,KAAK,cAAc,IAAI,CAAC,KAAK,YAAY,CAAC,EAC5C;oBACA,EAAE,CAAC,IAAI,CAAC,EAAC,OAAO,EAAE,QAAQ,EAAC,CAAC,CAAC;iBAC9B;YACH,CAAC,CAAC,CAAC;SACJ;QACD,OAAO,EAAE,CAAC;IACZ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,IAAI,CAAC;KACb;IAED,iCAAiC;IACjC,IAAI,MAAmB,CAAC;IACxB,IAAI,eAAe,CAAC,KAAK,KAAK,SAAS,EAAE;QACvC,MAAM,GAAG,eAAe,CAAC,KAAK,CAAC;KAChC;SAAM,IAAI,QAAQ,CAAC,sBAAsB,EAAE,IAAI,CAAC,EAAE;QACjD,iEAAiE;QACjE,MAAM,GAAG,eAAe,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;KAC/C;SAAM;QACL,MAAM,GAAG,WAAW,CAAC;KACtB;IAED,IAAI,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE;QACrC,OAAO,IAAI,CAAC;KACb;IAED,gCAAgC;IAChC,IAAI,eAAe,CAAC,KAAK,IAAI,eAAe,CAAC,KAAK,CAAC,IAAI,IAAI,eAAe,CAAC,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC,MAAM,EAAE;QAC1G,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,yBAAyB,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;KAC7E;IAED,+BAA+B;IAC/B,IAAI,eAAe,CAAC,QAAQ,EAAE,YAAY,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE;QAC3D,IAAI,eAAe,CAAC,KAAK,KAAK,SAAS,EAAE;YACvC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,qBAAqB,CAAC,YAAY,CAAC,CAAC,CAAC;SAC3D;QACD,OAAO,IAAI,CAAC;KACb;IAED,uCAAuC;IACvC,IAAI,eAAe,CAAC,SAAS,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,eAAe,CAAC,SAAS,CAAC,EAAE;QAC9E,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,0BAA0B,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,CAAC;KAC7E;IAED,OAAO;QACL,cAAc,EAAE,YAAY,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,SAAS;QAC3D,YAAY;QACZ,MAAM,EAAE,UAAU,CAAC,IAAI,CAAC;QACxB,OAAO;QACP,MAAM;KACP,CAAC;AACJ,CAAC","sourcesContent":["import {isArray} from 'vega-util';\nimport {SUM_OPS} from './aggregate';\nimport {NONPOSITION_CHANNELS, NonPositionChannel, X, X2, Y2} from './channel';\nimport {channelHasField, Encoding} from './encoding';\nimport {\n  Field,\n  getTypedFieldDef,\n  isFieldDef,\n  isStringFieldDef,\n  PositionFieldDef,\n  TypedFieldDef,\n  vgField\n} from './fielddef';\nimport * as log from './log';\nimport {AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, Mark, MarkDef, POINT, RULE, SQUARE, TEXT, TICK} from './mark';\nimport {ScaleType} from './scale';\nimport {contains, Flag, getFirstDefined} from './util';\n\nexport type StackOffset = 'zero' | 'center' | 'normalize';\n\nconst STACK_OFFSET_INDEX: Flag<StackOffset> = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\n\nexport function isStackOffset(s: string): s is StackOffset {\n  return !!STACK_OFFSET_INDEX[s];\n}\n\nexport interface StackProperties {\n  /** Dimension axis of the stack. */\n  groupbyChannel: 'x' | 'y';\n\n  /** Measure axis of the stack. */\n  fieldChannel: 'x' | 'y';\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: TypedFieldDef<string>;\n    channel: NonPositionChannel;\n  }[];\n\n  /**\n   * See `\"stack\"` property of Position Field Def.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether this stack will produce impute transform\n   */\n  impute: boolean;\n}\n\nexport const STACKABLE_MARKS = [BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK];\nexport const STACK_BY_DEFAULT_MARKS = [BAR, AREA];\n\nfunction potentialStackedChannel(encoding: Encoding<Field>): 'x' | 'y' | undefined {\n  const xDef = encoding.x;\n  const yDef = encoding.y;\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (xDef.type === 'quantitative' && yDef.type === 'quantitative') {\n      if (xDef.stack) {\n        return 'x';\n      } else if (yDef.stack) {\n        return 'y';\n      }\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if (!!xDef.aggregate !== !!yDef.aggregate) {\n        return xDef.aggregate ? 'x' : 'y';\n      }\n    } else if (xDef.type === 'quantitative') {\n      return 'x';\n    } else if (yDef.type === 'quantitative') {\n      return 'y';\n    }\n  } else if (isFieldDef(xDef) && xDef.type === 'quantitative') {\n    return 'x';\n  } else if (isFieldDef(yDef) && yDef.type === 'quantitative') {\n    return 'y';\n  }\n  return undefined;\n}\n\n// Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\nexport function stack(m: Mark | MarkDef, encoding: Encoding<Field>, stackConfig: StackOffset): StackProperties {\n  const mark = isMarkDef(m) ? m.type : m;\n  // Should have stackable mark\n  if (!contains(STACKABLE_MARKS, mark)) {\n    return null;\n  }\n\n  const fieldChannel = potentialStackedChannel(encoding);\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel] as PositionFieldDef<string>;\n  const stackedField = isStringFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n\n  const dimensionChannel = fieldChannel === 'x' ? 'y' : 'x';\n  const dimensionDef = encoding[dimensionChannel];\n  const dimensionField = isStringFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n\n  // Should have grouping level of detail that is different from the dimension field\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach(cDef => {\n        const fieldDef = getTypedFieldDef(cDef);\n        if (fieldDef.aggregate) {\n          return;\n        }\n\n        // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n        const f = isStringFieldDef(fieldDef) ? vgField(fieldDef, {}) : undefined;\n        if (\n          // if fielddef is a repeat, just include it in the stack by\n          !f ||\n          // otherwise, the field must be different from x and y fields.\n          (f !== dimensionField && f !== stackedField)\n        ) {\n          sc.push({channel, fieldDef});\n        }\n      });\n    }\n    return sc;\n  }, []);\n\n  if (stackBy.length === 0) {\n    return null;\n  }\n\n  // Automatically determine offset\n  let offset: StackOffset;\n  if (stackedFieldDef.stack !== undefined) {\n    offset = stackedFieldDef.stack;\n  } else if (contains(STACK_BY_DEFAULT_MARKS, mark)) {\n    // Bar and Area with sum ops are automatically stacked by default\n    offset = getFirstDefined(stackConfig, 'zero');\n  } else {\n    offset = stackConfig;\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  // warn when stacking non-linear\n  if (stackedFieldDef.scale && stackedFieldDef.scale.type && stackedFieldDef.scale.type !== ScaleType.LINEAR) {\n    log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n  }\n\n  // Check if it is a ranged mark\n  if (channelHasField(encoding, fieldChannel === X ? X2 : Y2)) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n\n  // Warn if stacking summative aggregate\n  if (stackedFieldDef.aggregate && !contains(SUM_OPS, stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannel: dimensionDef ? dimensionChannel : undefined,\n    fieldChannel,\n    impute: isPathMark(mark),\n    stackBy,\n    offset\n  };\n}\n"]}