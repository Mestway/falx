{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/compositemark/common.ts"],"names":[],"mappings":";AAAA,OAAO,EAAC,SAAS,EAAE,QAAQ,EAAC,MAAM,WAAW,CAAC;AAG9C,OAAO,EAAW,SAAS,EAAE,MAAM,EAAC,MAAM,aAAa,CAAC;AACxD,OAAO,EAIL,YAAY,EACZ,UAAU,EAIX,MAAM,aAAa,CAAC;AACrB,OAAO,KAAK,GAAG,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAA8B,SAAS,EAA4B,MAAM,SAAS,CAAC;AA+B1F,MAAM,UAAU,uBAAuB,CACrC,cAA6C,EAC7C,wBAAkD,EAClD,6BAA+C,EAC/C,gBAAyB,IAAI;IAE7B,MAAM,kBAAkB,GAA2B,cAAc,CAAC,GAAG,CACnE,CAAC,EAAC,WAAW,EAAE,WAAW,EAAC,EAAwB,EAAE,CAAC,CAAC;QACrD,KAAK,EAAE,WAAW,GAAG,wBAAwB,CAAC,KAAK;QACnD,IAAI,EAAE,wBAAwB,CAAC,IAAI;QACnC,KAAK,EAAE,WAAW,GAAG,CAAC,aAAa,CAAC,CAAC,CAAC,MAAM,GAAG,wBAAwB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;KACpF,CAAC,CACH,CAAC;IAEF,OAAO;QACL,OAAO,EAAE;YACP,GAAG,kBAAkB;YACrB,+DAA+D;YAC/D,GAAI,SAAS,CAAC,6BAA6B,CAA4B;SACxE;KACF,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,iCAAiC,CAC/C,gBAAkD,EAClD,cAAyB,EACzB,wBAAkD,EAClD,cAAgC,EAChC,mBAAsB;IAEtB,MAAM,EAAC,KAAK,EAAE,IAAI,EAAC,GAAG,wBAAwB,CAAC;IAE/C,OAAO,CAAC,EACN,QAAQ,EACR,IAAI,EACJ,cAAc,EACd,iBAAiB,GAAG,SAAS,EAC7B,aAAa,GAAG,EAAE,EAOnB,EAAE,EAAE;QACH,MAAM,KAAK,GACT,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS;YAC9B,CAAC,CAAC,SAAS;YACX,CAAC,CAAC,wBAAwB,CAAC,KAAK,KAAK,SAAS;gBAC9C,CAAC,CAAC,wBAAwB,CAAC,KAAK;gBAChC,CAAC,CAAC,wBAAwB,CAAC,KAAK,CAAC;QAErC,OAAO,eAAe,CAAI,gBAAgB,EAAE,QAAQ,EAAE,mBAAmB,EAAE;YACzE,IAAI;YACJ,QAAQ,kBACN,CAAC,cAAc,CAAC,kBACd,KAAK,EAAE,cAAc,GAAG,GAAG,GAAG,wBAAwB,CAAC,KAAK,EAC5D,IAAI,EAAE,wBAAwB,CAAC,IAAI,IAChC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAC,KAAK,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EACtB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAC,KAAK,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EACtB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,KAEtB,CAAC,QAAQ,CAAC,iBAAiB,CAAC;gBAC7B,CAAC,CAAC;oBACE,CAAC,cAAc,GAAG,GAAG,CAAC,EAAE;wBACtB,KAAK,EAAE,iBAAiB,GAAG,GAAG,GAAG,wBAAwB,CAAC,KAAK;wBAC/D,IAAI,EAAE,wBAAwB,CAAC,IAAI;qBACpC;iBACF;gBACH,CAAC,CAAC,EAAE,CAAC,EACJ,cAAc,EACd,aAAa,CACjB;SACF,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,eAAe,CAC7B,OAAyC,EACzC,IAAa,EACb,mBAAsB,EACtB,YAAgC;IAEhC,MAAM,EAAC,IAAI,EAAE,KAAK,EAAE,OAAO,EAAC,GAAG,OAAO,CAAC;IAEvC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;IAE1B,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,SAAS,IAAI,mBAAmB,CAAC,IAAI,CAAC,CAAC,EAAE;QAC/E,OAAO;8BAEA,YAAY,IACf,IAAI,oBACE,mBAAmB,CAAC,IAAI,CAAgB,EACzC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EACpB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAC,KAAK,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EACtB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAC,OAAO,EAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAC1B,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAC,IAAI,EAAE,YAAY,CAAC,IAAI,EAAC,CAAC,IACjF,KAAK,EAAE,GAAG,IAAI,IAAI,IAAI,EAAE,IACrB,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAE,OAAO,CAAC,IAAI,CAAgB,CAAC;SAGvE,CAAC;KACH;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AAED,MAAM,UAAU,2BAA2B,CACzC,IAAyE,EACzE,MAAc,EACd,aAAgB;IAEhB,MAAM,EAAC,QAAQ,EAAC,GAAG,IAAI,CAAC;IACxB,MAAM,cAAc,GAAc,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IAEpE,MAAM,wBAAwB,GAAG,QAAQ,CAAC,cAAc,CAA6B,CAAC,CAAC,4FAA4F;IACnL,MAAM,yBAAyB,GAAG,QAAQ,CAAC,cAAc,GAAG,GAAG,CAA8B,CAAC;IAC9F,MAAM,6BAA6B,GAAG,QAAQ,CAAC,cAAc,GAAG,OAAO,CAAiC,CAAC;IACzG,MAAM,8BAA8B,GAAG,QAAQ,CAAC,cAAc,GAAG,QAAQ,CAAiC,CAAC;IAE3G,OAAO;QACL,wBAAwB,EAAE,6BAA6B,CAAC,wBAAwB,EAAE,aAAa,CAAC;QAChG,yBAAyB,EAAE,6BAA6B,CAAC,yBAAyB,EAAE,aAAa,CAAC;QAClG,6BAA6B,EAAE,6BAA6B,CAAC,6BAA6B,EAAE,aAAa,CAAC;QAC1G,8BAA8B,EAAE,6BAA6B,CAAC,8BAA8B,EAAE,aAAa,CAAC;QAC5G,cAAc;KACf,CAAC;AACJ,CAAC;AAED,SAAS,6BAA6B,CACpC,wBAA2B,EAC3B,aAAgB;IAEhB,IAAI,UAAU,CAAC,wBAAwB,CAAC,IAAI,wBAAwB,IAAI,wBAAwB,CAAC,SAAS,EAAE;QAC1G,MAAM,EAAC,SAAS,KAAuC,wBAAwB,EAA7D,wFAA6D,CAAC;QAChF,IAAI,SAAS,KAAK,aAAa,EAAE;YAC/B,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,4CAA4C,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC,CAAC;SAC9F;QACD,OAAO,8BAAmC,CAAC;KAC5C;SAAM;QACL,OAAO,wBAAwB,CAAC;KACjC;AACH,CAAC;AAED,MAAM,UAAU,mBAAmB,CACjC,IAAwE,EACxE,aAAgB;IAEhB,MAAM,EAAC,IAAI,EAAE,QAAQ,EAAC,GAAG,IAAI,CAAC;IAE9B,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE;QACtD,kBAAkB;QAClB,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE;YACtD,8BAA8B;YAC9B,IAAI,QAAQ,CAAC,CAAC,CAAC,SAAS,KAAK,SAAS,IAAI,QAAQ,CAAC,CAAC,CAAC,SAAS,KAAK,aAAa,EAAE;gBAChF,OAAO,UAAU,CAAC;aACnB;iBAAM,IAAI,QAAQ,CAAC,CAAC,CAAC,SAAS,KAAK,SAAS,IAAI,QAAQ,CAAC,CAAC,CAAC,SAAS,KAAK,aAAa,EAAE;gBACvF,OAAO,YAAY,CAAC;aACrB;iBAAM,IAAI,QAAQ,CAAC,CAAC,CAAC,SAAS,KAAK,aAAa,IAAI,QAAQ,CAAC,CAAC,CAAC,SAAS,KAAK,aAAa,EAAE;gBAC3F,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;aACvD;iBAAM;gBACL,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,EAAE;oBAClC,OAAO,IAAI,CAAC,MAAM,CAAC;iBACpB;gBAED,iCAAiC;gBACjC,OAAO,UAAU,CAAC;aACnB;SACF;QAED,+BAA+B;QAC/B,OAAO,YAAY,CAAC;KACrB;SAAM,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE;QAC7D,+BAA+B;QAC/B,OAAO,UAAU,CAAC;KACnB;SAAM;QACL,iCAAiC;QACjC,MAAM,IAAI,KAAK,CAAC,mCAAmC,GAAG,aAAa,GAAG,GAAG,CAAC,CAAC;KAC5E;AACH,CAAC;AAED,MAAM,UAAU,yBAAyB,CACvC,IAA+C,EAC/C,iBAA4B,EAC5B,aAAgB;IAEhB,yBACK,IAAI,IACP,QAAQ,EAAE,MAAM,CACd,IAAI,CAAC,QAAQ,EACb,CAAC,WAAW,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE;YACjC,IAAI,iBAAiB,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE;gBAC3C,WAAW,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAC;aACjC;iBAAM;gBACL,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC,CAAC;aACnE;YACD,OAAO,WAAW,CAAC;QACrB,CAAC,EACD,EAAE,CACH,IACD;AACJ,CAAC","sourcesContent":["import {isBoolean, isString} from 'vega-util';\nimport {CompositeMark, CompositeMarkDef} from '.';\nimport {Channel} from '../channel';\nimport {Encoding, fieldDefs, reduce} from '../encoding';\nimport {\n  Field,\n  FieldDefBase,\n  FieldDefWithoutScale,\n  isContinuous,\n  isFieldDef,\n  PositionFieldDef,\n  SecondaryFieldDef,\n  TextFieldDef\n} from '../fielddef';\nimport * as log from '../log';\nimport {ColorMixins, GenericMarkDef, isMarkDef, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {Orient} from '../vega.schema';\n\nexport type PartsMixins<P extends string> = Partial<Record<P, boolean | MarkConfig>>;\n\nexport type GenericCompositeMarkDef<T> = GenericMarkDef<T> &\n  ColorMixins & {\n    /**\n     * The opacity (value between [0,1]) of the mark.\n     */\n    opacity?: number;\n\n    /**\n     * Whether a composite mark be clipped to the enclosing groupâ€™s width and height.\n     */\n    clip?: boolean;\n  };\n\nexport interface CompositeMarkTooltipSummary {\n  /**\n   * The prefix of the field to be shown in tooltip\n   */\n  fieldPrefix: string;\n\n  /**\n   * The title prefix to show, corresponding to the field with field prefix `fieldPrefix`\n   */\n  titlePrefix: string;\n}\n\nexport function getCompositeMarkTooltip(\n  tooltipSummary: CompositeMarkTooltipSummary[],\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  encodingWithoutContinuousAxis: Encoding<string>,\n  withFieldName: boolean = true\n): Encoding<string> {\n  const fiveSummaryTooltip: TextFieldDef<string>[] = tooltipSummary.map(\n    ({fieldPrefix, titlePrefix}): TextFieldDef<string> => ({\n      field: fieldPrefix + continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type,\n      title: titlePrefix + (withFieldName ? ' of ' + continuousAxisChannelDef.field : '')\n    })\n  );\n\n  return {\n    tooltip: [\n      ...fiveSummaryTooltip,\n      // need to cast because TextFieldDef support fewer types of bin\n      ...(fieldDefs(encodingWithoutContinuousAxis) as TextFieldDef<string>[])\n    ]\n  };\n}\n\nexport function makeCompositeAggregatePartFactory<P extends PartsMixins<any>>(\n  compositeMarkDef: GenericCompositeMarkDef<any> & P,\n  continuousAxis: 'x' | 'y',\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  sharedEncoding: Encoding<string>,\n  compositeMarkConfig: P\n) {\n  const {scale, axis} = continuousAxisChannelDef;\n\n  return ({\n    partName,\n    mark,\n    positionPrefix,\n    endPositionPrefix = undefined,\n    extraEncoding = {}\n  }: {\n    partName: keyof P;\n    mark: Mark | MarkDef;\n    positionPrefix: string;\n    endPositionPrefix?: string;\n    extraEncoding?: Encoding<string>;\n  }) => {\n    const title =\n      axis && axis.title !== undefined\n        ? undefined\n        : continuousAxisChannelDef.title !== undefined\n        ? continuousAxisChannelDef.title\n        : continuousAxisChannelDef.field;\n\n    return partLayerMixins<P>(compositeMarkDef, partName, compositeMarkConfig, {\n      mark, // TODO better remove this method and just have mark as a parameter of the method\n      encoding: {\n        [continuousAxis]: {\n          field: positionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type,\n          ...(title ? {title} : {}),\n          ...(scale ? {scale} : {}),\n          ...(axis ? {axis} : {})\n        },\n        ...(isString(endPositionPrefix)\n          ? {\n              [continuousAxis + '2']: {\n                field: endPositionPrefix + '_' + continuousAxisChannelDef.field,\n                type: continuousAxisChannelDef.type\n              }\n            }\n          : {}),\n        ...sharedEncoding,\n        ...extraEncoding\n      }\n    });\n  };\n}\n\nexport function partLayerMixins<P extends PartsMixins<any>>(\n  markDef: GenericCompositeMarkDef<any> & P,\n  part: keyof P,\n  compositeMarkConfig: P,\n  partBaseSpec: NormalizedUnitSpec\n): NormalizedUnitSpec[] {\n  const {clip, color, opacity} = markDef;\n\n  const mark = markDef.type;\n\n  if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n    return [\n      {\n        ...partBaseSpec,\n        mark: {\n          ...(compositeMarkConfig[part] as MarkConfig),\n          ...(clip ? {clip} : {}),\n          ...(color ? {color} : {}),\n          ...(opacity ? {opacity} : {}),\n          ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type: partBaseSpec.mark}),\n          style: `${mark}-${part}`,\n          ...(isBoolean(markDef[part]) ? {} : (markDef[part] as MarkConfig))\n        }\n      }\n    ];\n  }\n  return [];\n}\n\nexport function compositeMarkContinuousAxis<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  orient: Orient,\n  compositeMark: M\n) {\n  const {encoding} = spec;\n  const continuousAxis: 'x' | 'y' = orient === 'vertical' ? 'y' : 'x';\n\n  const continuousAxisChannelDef = encoding[continuousAxis] as PositionFieldDef<string>; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n  const continuousAxisChannelDef2 = encoding[continuousAxis + '2'] as SecondaryFieldDef<string>;\n  const continuousAxisChannelDefError = encoding[continuousAxis + 'Error'] as FieldDefWithoutScale<string>;\n  const continuousAxisChannelDefError2 = encoding[continuousAxis + 'Error2'] as FieldDefWithoutScale<string>;\n\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef<M extends CompositeMark, F extends FieldDefBase<string>>(\n  continuousAxisChannelDef: F,\n  compositeMark: M\n): F {\n  if (isFieldDef(continuousAxisChannelDef) && continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    return continuousAxisWithoutAggregate as F;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<Field>, CompositeMark | CompositeMarkDef>,\n  compositeMark: M\n): Orient {\n  const {mark, encoding} = spec;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === compositeMark) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === compositeMark) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === compositeMark && encoding.y.aggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isMarkDef(mark) && mark.orient) {\n          return mark.orient;\n        }\n\n        // default orientation = vertical\n        return 'vertical';\n      }\n    }\n\n    // x is continuous but y is not\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for ' + compositeMark + 's');\n  }\n}\n\nexport function filterUnsupportedChannels<M extends CompositeMark, MD extends GenericCompositeMarkDef<M>>(\n  spec: GenericUnitSpec<Encoding<string>, M | MD>,\n  supportedChannels: Channel[],\n  compositeMark: M\n): GenericUnitSpec<Encoding<string>, M | MD> {\n  return {\n    ...spec,\n    encoding: reduce(\n      spec.encoding,\n      (newEncoding, fieldDef, channel) => {\n        if (supportedChannels.indexOf(channel) > -1) {\n          newEncoding[channel] = fieldDef;\n        } else {\n          log.warn(log.message.incompatibleChannel(channel, compositeMark));\n        }\n        return newEncoding;\n      },\n      {}\n    )\n  };\n}\n"]}