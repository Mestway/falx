{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/spec/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {Config} from '../config';\nimport * as vlEncoding from '../encoding';\nimport {forEach} from '../encoding';\nimport {Field, FieldDef, isFieldDef, TypedFieldDef} from '../fielddef';\nimport * as log from '../log';\nimport {isPrimitiveMark} from '../mark';\nimport {stack} from '../stack';\nimport {Dict, hash, vals} from '../util';\nimport {DataMixins} from './base';\nimport {GenericHConcatSpec, GenericVConcatSpec, isConcatSpec, isVConcatSpec} from './concat';\nimport {GenericFacetSpec, isFacetSpec, NormalizedFacetSpec} from './facet';\nimport {ExtendedLayerSpec, GenericLayerSpec, isLayerSpec, NormalizedLayerSpec} from './layer';\nimport {GenericRepeatSpec, isRepeatSpec, NormalizedRepeatSpec} from './repeat';\nimport {TopLevel} from './toplevel';\nimport {FacetedCompositeUnitSpec, GenericUnitSpec, isUnitSpec, NormalizedUnitSpec} from './unit';\n\nexport {normalizeTopLevelSpec as normalize} from '../normalize';\nexport {BaseSpec, DataMixins, LayoutSizeMixins} from './base';\nexport {\n  GenericHConcatSpec,\n  GenericVConcatSpec,\n  isConcatSpec,\n  isHConcatSpec,\n  isVConcatSpec,\n  NormalizedConcatSpec\n} from './concat';\nexport {GenericFacetSpec, isFacetSpec, NormalizedFacetSpec} from './facet';\nexport {ExtendedLayerSpec, GenericLayerSpec, isLayerSpec, NormalizedLayerSpec} from './layer';\nexport {GenericRepeatSpec, isRepeatSpec, NormalizedRepeatSpec} from './repeat';\nexport {TopLevel} from './toplevel';\nexport {CompositeUnitSpec, FacetedCompositeUnitSpec, GenericUnitSpec, isUnitSpec, NormalizedUnitSpec} from './unit';\n\nexport type GenericSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>> =\n  | U\n  | L\n  | GenericFacetSpec<U, L>\n  | GenericRepeatSpec<U, L>\n  | GenericVConcatSpec<U, L>\n  | GenericHConcatSpec<U, L>;\n\nexport type NormalizedSpec = GenericSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport type TopLevelFacetedUnitSpec = TopLevel<FacetedCompositeUnitSpec> & DataMixins;\nexport type TopLevelFacetSpec = TopLevel<GenericFacetSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>> & DataMixins;\n\n/**\n * A Vega-Lite top-level specification.\n * This is the root class for all Vega-Lite specifications.\n * (The json schema is generated from this type.)\n */\nexport type TopLevelSpec =\n  | TopLevelFacetedUnitSpec\n  | TopLevelFacetSpec\n  | TopLevel<ExtendedLayerSpec>\n  | TopLevel<GenericRepeatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>\n  | TopLevel<GenericVConcatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>\n  | TopLevel<GenericHConcatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>;\n\n/* Custom type guards */\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\n/* Accumulate non-duplicate fieldDefs in a dictionary */\nfunction accumulate(dict: any, defs: FieldDef<Field>[]): any {\n  defs.forEach(fieldDef => {\n    // Consider only pure fieldDef properties (ignoring scale, axis, legend)\n    const pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce((f, key) => {\n      if (fieldDef[key] !== undefined) {\n        f[key] = fieldDef[key];\n      }\n      return f;\n    }, {});\n    const key = hash(pureFieldDef);\n    dict[key] = dict[key] || fieldDef;\n  });\n  return dict;\n}\n\n/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */\nfunction fieldDefIndex<F extends Field>(\n  spec: GenericSpec<any, any>,\n  dict: Dict<TypedFieldDef<F>> = {}\n): Dict<TypedFieldDef<F>> {\n  // FIXME(https://github.com/vega/vega-lite/issues/2207): Support fieldDefIndex for repeat\n  if (isLayerSpec(spec)) {\n    spec.layer.forEach(layer => {\n      if (isUnitSpec(layer)) {\n        accumulate(dict, vlEncoding.fieldDefs(layer.encoding));\n      } else {\n        fieldDefIndex(layer, dict);\n      }\n    });\n  } else if (isFacetSpec(spec)) {\n    accumulate(dict, vlEncoding.fieldDefs(spec.facet));\n    fieldDefIndex(spec.spec, dict);\n  } else if (isRepeatSpec(spec)) {\n    fieldDefIndex(spec.spec, dict);\n  } else if (isConcatSpec(spec)) {\n    const childSpec = isVConcatSpec(spec) ? spec.vconcat : spec.hconcat;\n    childSpec.forEach(child => fieldDefIndex(child, dict));\n  } else {\n    // Unit Spec\n    accumulate(dict, vlEncoding.fieldDefs(spec.encoding));\n  }\n  return dict;\n}\n\n/* Returns all non-duplicate fieldDefs in a spec in a flat array */\nexport function fieldDefs(spec: GenericSpec<any, any>): TypedFieldDef<any>[] {\n  return vals(fieldDefIndex(spec));\n}\n\nexport function isStacked(spec: TopLevel<FacetedCompositeUnitSpec>, config?: Config): boolean {\n  config = config || spec.config;\n  if (isPrimitiveMark(spec.mark)) {\n    return stack(spec.mark, spec.encoding, config ? config.stack : undefined) !== null;\n  }\n  return false;\n}\n\n/**\n * Takes a spec and returns a list of fields used in encoding\n */\nexport function usedFields(spec: NormalizedSpec): string[] {\n  if (isFacetSpec(spec) || isRepeatSpec(spec)) {\n    return usedFieldsSingle(spec);\n  }\n  if (isLayerSpec(spec)) {\n    return usedFieldsLayered(spec);\n  }\n  if (isUnitSpec(spec)) {\n    return usedFieldsUnit(spec);\n  }\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nfunction usedFieldsUnit(spec: NormalizedUnitSpec): string[] {\n  const fields: string[] = [];\n  forEach(spec.encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      fields.push(channelDef.field);\n    }\n  });\n  return fields;\n}\n\nfunction usedFieldsLayered(spec: NormalizedLayerSpec): string[] {\n  let fields: string[] = [];\n  spec.layer.map(subspec => {\n    fields = fields.concat(usedFields(subspec));\n  });\n  return fields;\n}\n\nfunction usedFieldsSingle(spec: NormalizedFacetSpec | NormalizedRepeatSpec): string[] {\n  return usedFields(spec.spec);\n}\n"]}